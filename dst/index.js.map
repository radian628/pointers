{
  "version": 3,
  "sources": ["../src/lexing.tsx", "../src/runtime/runtime.tsx", "../src/typecheck.tsx", "../src/parser-utils.tsx", "../src/nodes/BinaryOpNode.tsx", "../src/nodes/AssignmentNode.tsx", "../src/nodes/ErrorNode.tsx", "../src/nodes/FunctionCallNode.tsx", "../src/nodes/FunctionDefNode.tsx", "../src/nodes/IdentifierNode.tsx", "../src/nodes/IfNode.tsx", "../src/nodes/LoopNode.tsx", "../src/nodes/NumberNode.tsx", "../src/nodes/ReturnStatementNode.tsx", "../src/nodes/StatementListNode.tsx", "../src/nodes/StringLiteralNode.tsx", "../src/nodes/StructDefinitionNode.tsx", "../src/nodes/TypecastNode.tsx", "../src/nodes/UnaryOpNode.tsx", "../src/nodes/VariableDefinitionNode.tsx", "../src/nodes/DefinitionNode.tsx", "../src/nodes/ElseNode.tsx", "../src/nodes/TypeAnnotationNode.tsx", "../src/ast.tsx", "../src/allocate.tsx", "../src/parser.tsx", "../src/index.tsx"],
  "sourcesContent": ["const hexDigit = \"[0-9a-fA-F]\";\r\n\r\nconst stringLiteralWithEscapeCodesAnd = (strs: string[]) =>\r\n  [\r\n    \"\\\\\\\\(n|t|r|0|\\\\\\\\)\",\r\n    `\\\\\\\\x${hexDigit}{2}`,\r\n    `\\\\\\\\u${hexDigit}{4}`,\r\n    ...strs,\r\n  ].join(\"|\");\r\n\r\nexport const charLiteralRegex = new RegExp(\r\n  `'(${stringLiteralWithEscapeCodesAnd([\"[^']\"])})'`\r\n);\r\nexport const stringLiteralRegex = new RegExp(\r\n  `\"(${stringLiteralWithEscapeCodesAnd(['[^\"]'])})*\"`\r\n);\r\nexport const numberRegex = /[0-9]+(\\.[0-9]*)?/;\r\nexport const identRegex = /[a-zA-Z_][a-zA-Z0-9_]*/;\r\nexport const skipRegex = /[ \\r\\t\\n]+/;\r\nexport const opRegex = [\r\n  \"+\",\r\n  \"-\",\r\n  \"*\",\r\n  \"/\",\r\n  \"||\",\r\n  \"&&\",\r\n  \"^^\",\r\n  \"==\",\r\n  \"!=\",\r\n  \">=\",\r\n  \"<=\",\r\n  \">\",\r\n  \"<\",\r\n  \"&\",\r\n  \"|\",\r\n  \"^\",\r\n  \"<<\",\r\n  \">>\",\r\n  \".\",\r\n  \"->\",\r\n  \"%\",\r\n] as const;\r\nexport const numberTypeRegex = /[fui]/g;\r\nexport type Operator = (typeof opRegex)[number];\r\n\r\nexport const unaryOpRegex = [\"!\", \"*\", \"&\", \"~\"] as const;\r\nexport type UnaryOperator = (typeof unaryOpRegex)[number];\r\n", "import {\r\n  ExecutionError,\r\n  FunctionDefNode,\r\n  ParseExpr,\r\n  TypeAnnotationNode,\r\n} from \"../ast\";\r\n\r\n// primitive type definition\r\ntype PrimitiveTypeDefinition =\r\n  | {\r\n      size: 1 | 2 | 4 | 8;\r\n      category: \"int\" | \"uint\";\r\n      name: string;\r\n    }\r\n  | {\r\n      size: 4 | 8;\r\n      category: \"float\";\r\n      name: string;\r\n    };\r\n\r\n// struct type definition\r\ntype StructTypeDefinition = {\r\n  category: \"struct\";\r\n  fields: [string, Type][];\r\n  name: string;\r\n};\r\n\r\n/// any type definition\r\nexport type TypeDefinition = PrimitiveTypeDefinition | StructTypeDefinition;\r\n\r\n// directory of all defined types\r\ntype DefinedTypes = Map<string, TypeDefinition>;\r\n\r\n// all-encompassing thing for representing types\r\nexport type Type = {\r\n  pointers: number;\r\n  definition: TypeDefinition;\r\n};\r\n\r\n// points to an actual instance of a variable in memory\r\nexport type AnonymousVariableInstance = {\r\n  type: Type;\r\n  offset: number;\r\n};\r\nexport type VariableInstance = AnonymousVariableInstance & {\r\n  name: string;\r\n};\r\n\r\nexport type StackFrame = {\r\n  base: number;\r\n  bindings: Map<string, VariableInstance>;\r\n  temporaries: AnonymousVariableInstance[];\r\n  functionDefinitions: Map<\r\n    string,\r\n    | {\r\n        type: \"internal\";\r\n        def: FunctionDefNode;\r\n      }\r\n    | {\r\n        type: \"external\";\r\n        def: (ctx: ExecutionContext, args: ParseExpr[]) => ExecutionContext;\r\n      }\r\n  >;\r\n  freed: boolean;\r\n  returnType: Type;\r\n  argc: number;\r\n  blocks: {\r\n    bindings: Map<string, VariableInstance>;\r\n  }[];\r\n};\r\n\r\nfunction assert(cond: any, msg: string) {\r\n  if (!cond) throw new Error(\"ASSERTION FAILED: \" + msg);\r\n}\r\n\r\nexport function notNull<T>(\r\n  v: T | undefined | null,\r\n  name: string,\r\n  ctx: ExecutionContext\r\n): T {\r\n  if (v === undefined || v === null) {\r\n    console.log(ctx);\r\n    throw new ExecutionError(`EXPECTED ${name} TO NOT BE UNDEFINED.`, ctx);\r\n  }\r\n  return v;\r\n}\r\n\r\nexport function assertPrimitiveTypeDef(\r\n  def: TypeDefinition\r\n): PrimitiveTypeDefinition {\r\n  if (def.category === \"struct\")\r\n    throw new Error(\"GOT UNEXPECTED STRUCT TYPEDEF\");\r\n\r\n  return def;\r\n}\r\n\r\nfunction bigintify(n: number, type: Type): number | bigint {\r\n  if (\r\n    (type.definition.category === \"int\" ||\r\n      type.definition.category === \"uint\") &&\r\n    type.definition.size === 8\r\n  )\r\n    return BigInt(n);\r\n\r\n  return n;\r\n}\r\n\r\n// TODO: make sure that editing one context doesn't affect previous ones\r\n// ideally all of these execution contexts should be able to function independently\r\n// of one another\r\nexport class ExecutionContext {\r\n  types: DefinedTypes;\r\n  memory: ArrayBuffer;\r\n  view: DataView;\r\n  esp: number;\r\n  littleEndian: boolean;\r\n  prev?: ExecutionContext;\r\n  stack: StackFrame[];\r\n\r\n  constructor(\r\n    opts: {\r\n      littleEndian: boolean;\r\n      memory: ArrayBuffer;\r\n      stack: StackFrame[];\r\n      esp: number;\r\n      types: DefinedTypes;\r\n    },\r\n    prev?: ExecutionContext\r\n  ) {\r\n    this.stack = opts.stack;\r\n    this.memory = opts.memory;\r\n    this.littleEndian = opts.littleEndian;\r\n    this.view = new DataView(this.memory);\r\n    this.prev = prev;\r\n    this.types = opts.types;\r\n    this.esp = opts.esp;\r\n  }\r\n\r\n  getvar(name: string) {\r\n    return (\r\n      this.stacktop().bindings.get(name) ?? this.stack[0].bindings.get(name)\r\n    );\r\n  }\r\n\r\n  clone() {\r\n    return new ExecutionContext(\r\n      {\r\n        memory: this.memory,\r\n        littleEndian: this.littleEndian,\r\n        stack: this.stack,\r\n        esp: this.esp,\r\n        types: this.types,\r\n      },\r\n      this\r\n    );\r\n  }\r\n\r\n  sizeof(type: Type) {\r\n    if (type.pointers > 0) return 4;\r\n\r\n    if (type.definition.category === \"struct\") {\r\n      return type.definition.fields.reduce(\r\n        (prev, field) => prev + this.sizeof(field[1]),\r\n        0\r\n      );\r\n    }\r\n\r\n    return type.definition.size;\r\n  }\r\n\r\n  _setStruct(instance: AnonymousVariableInstance, value: ArrayBuffer) {\r\n    const mem = new Uint8Array(this.memory.slice(instance.offset));\r\n    const valAsUint8array = new Uint8Array(value);\r\n    const size = this.sizeof(instance.type);\r\n    for (let i = 0; i < size; i++) {\r\n      mem[i] = valAsUint8array[i];\r\n    }\r\n  }\r\n\r\n  _getStruct(instance: AnonymousVariableInstance) {\r\n    return this.memory.slice(\r\n      instance.offset,\r\n      instance.offset + this.sizeof(instance.type)\r\n    );\r\n  }\r\n\r\n  setVar(\r\n    instance: AnonymousVariableInstance,\r\n    value: bigint | number | ArrayBuffer\r\n  ) {\r\n    if (instance.type.definition.category === \"struct\")\r\n      return this._setStruct(instance, value as ArrayBuffer);\r\n\r\n    const typecode =\r\n      instance.type.definition.category + instance.type.definition.size;\r\n\r\n    const useBigInt = typecode === \"int8\" || typecode === \"uint8\";\r\n\r\n    const setterFn =\r\n      instance.type.pointers > 0\r\n        ? this.view.setUint32\r\n        : {\r\n            int1: this.view.setInt8,\r\n            int2: this.view.setInt16,\r\n            int4: this.view.setInt32,\r\n            int8: this.view.setBigInt64,\r\n            uint1: this.view.setUint8,\r\n            uint2: this.view.setUint16,\r\n            uint4: this.view.setUint32,\r\n            uint8: this.view.setBigUint64,\r\n            float4: this.view.setFloat32,\r\n            float8: this.view.setFloat64,\r\n          }[typecode];\r\n\r\n    assert(setterFn, `setterFn exists (typecode ${typecode})`);\r\n\r\n    return setterFn?.apply(this.view, [\r\n      instance.offset,\r\n      // @ts-expect-error no thank you\r\n      useBigInt ? BigInt(value) : Number(value),\r\n      this.littleEndian,\r\n    ]);\r\n  }\r\n\r\n  getVar(instance: AnonymousVariableInstance): number | bigint | ArrayBuffer {\r\n    if (instance.type.definition.category === \"struct\")\r\n      return this._getStruct(instance);\r\n\r\n    const getterFn =\r\n      instance.type.pointers > 0\r\n        ? this.view.getUint32\r\n        : {\r\n            int1: this.view.getInt8,\r\n            int2: this.view.getInt16,\r\n            int4: this.view.getInt32,\r\n            int8: this.view.getBigInt64,\r\n            uint1: this.view.getUint8,\r\n            uint2: this.view.getUint16,\r\n            uint4: this.view.getUint32,\r\n            uint8: this.view.getBigUint64,\r\n            float4: this.view.getFloat32,\r\n            float8: this.view.getFloat64,\r\n          }[instance.type.definition.category + instance.type.definition.size];\r\n\r\n    assert(getterFn, \"getterFn exists\");\r\n\r\n    // @ts-expect-error no thank you\r\n    return getterFn.apply(this.view, [instance.offset, this.littleEndian]);\r\n  }\r\n\r\n  _push(\r\n    type: Type,\r\n    value: number | bigint | ArrayBuffer,\r\n    doNotSetVar?: boolean\r\n  ): AnonymousVariableInstance {\r\n    const esp = this.esp;\r\n\r\n    // initialize a zeroed-out struct\r\n    // TODO: figure out how ot deal with the fact that both struct + fields\r\n    // are loaded to teh stack. I think I only have to load the struct\r\n    // because you add/remove it from it all-in-one\r\n    if (type.definition.category === \"struct\" && type.pointers === 0) {\r\n      for (const [fieldname, fieldvalue] of type.definition.fields) {\r\n        this._push(fieldvalue, bigintify(0, fieldvalue));\r\n      }\r\n      return {\r\n        type,\r\n        offset: esp,\r\n      };\r\n    }\r\n\r\n    const varInstance = {\r\n      type,\r\n      offset: esp,\r\n    };\r\n\r\n    this.esp += this.sizeof(type);\r\n\r\n    if (!doNotSetVar) this.setVar(varInstance, value);\r\n\r\n    return varInstance;\r\n  }\r\n\r\n  stacktop() {\r\n    return this.stack[this.stack.length - 1];\r\n  }\r\n\r\n  blocktop() {\r\n    return this.stacktop().blocks[this.stacktop().blocks.length - 1];\r\n  }\r\n\r\n  pushAnonymous(type: Type, value: number | bigint | ArrayBuffer) {\r\n    const instance = this._push(type, value);\r\n\r\n    this.stacktop().temporaries.push(instance);\r\n  }\r\n\r\n  pushNamed(type: Type, value: number | bigint | ArrayBuffer, name: string) {\r\n    const instance = this._push(type, value);\r\n\r\n    const binding = {\r\n      ...instance,\r\n      name,\r\n    };\r\n\r\n    this.stacktop().bindings.set(name, binding);\r\n\r\n    this.blocktop().bindings.set(name, binding);\r\n  }\r\n\r\n  pushBlock() {\r\n    this.stacktop().blocks.push({\r\n      bindings: new Map(),\r\n    });\r\n  }\r\n\r\n  popBlock() {\r\n    // remove the block\r\n    const block = notNull(this.stacktop().blocks.pop(), \"block\", this);\r\n\r\n    // get rid of all the block's bindings\r\n    for (const [name, binding] of [...block.bindings].reverse()) {\r\n      this.esp -= this.sizeof(binding.type);\r\n\r\n      this.stacktop().bindings.delete(name);\r\n    }\r\n  }\r\n\r\n  popTempValue() {\r\n    const val = notNull(\r\n      this.stacktop().temporaries.pop(),\r\n      \"tempvalue in stack\",\r\n      this\r\n    );\r\n\r\n    this.esp -= this.sizeof(val.type);\r\n\r\n    return val;\r\n  }\r\n\r\n  popTempValueAndGetData() {\r\n    const val = this.popTempValue();\r\n    return this.getVar(val);\r\n  }\r\n\r\n  popTempValueAndGetBoth() {\r\n    const val = this.popTempValue();\r\n    return {\r\n      value: this.getVar(val),\r\n      typeinfo: val,\r\n    };\r\n  }\r\n\r\n  addFunctionDefinition(name: string, node: FunctionDefNode) {\r\n    this.stacktop().functionDefinitions.set(name, {\r\n      def: node,\r\n      type: \"internal\",\r\n    });\r\n  }\r\n\r\n  getFunctionDefinition(name: string) {\r\n    for (const frame of this.stack.slice().reverse()) {\r\n      const def = frame.functionDefinitions.get(name);\r\n      if (def) {\r\n        return def;\r\n      }\r\n    }\r\n  }\r\n\r\n  popStackFrame() {\r\n    const top = this.stack.pop();\r\n\r\n    if (!top) throw new ExecutionError(\"Popping off of an empty stack!\", this);\r\n\r\n    top.freed = true;\r\n    this.esp = top.base;\r\n\r\n    // pop function arguments\r\n    for (let i = 0; i < top.argc; i++) {\r\n      this.popTempValue();\r\n    }\r\n\r\n    return top;\r\n  }\r\n}\r\n\r\nexport const DefaultPrimitives = {\r\n  // integer types\r\n  long: {\r\n    size: 8,\r\n    category: \"int\",\r\n    name: \"long\",\r\n  },\r\n  int: {\r\n    size: 4,\r\n    category: \"int\",\r\n    name: \"int\",\r\n  },\r\n  short: {\r\n    size: 2,\r\n    category: \"int\",\r\n    name: \"short\",\r\n  },\r\n  char: {\r\n    size: 1,\r\n    category: \"int\",\r\n    name: \"char\",\r\n  },\r\n\r\n  // unsigned integer types\r\n  \"unsigned long\": {\r\n    size: 8,\r\n    category: \"int\",\r\n    name: \"unsigned long\",\r\n  },\r\n  \"unsigned int\": {\r\n    size: 4,\r\n    category: \"int\",\r\n    name: \"unsigned int\",\r\n  },\r\n  \"unsigned short\": {\r\n    size: 2,\r\n    category: \"int\",\r\n    name: \"unsigned short\",\r\n  },\r\n  \"unsigned char\": {\r\n    size: 1,\r\n    category: \"int\",\r\n    name: \"unsigned char\",\r\n  },\r\n\r\n  // floats\r\n  float: {\r\n    size: 4,\r\n    category: \"float\",\r\n    name: \"float\",\r\n  },\r\n  double: {\r\n    size: 8,\r\n    category: \"float\",\r\n    name: \"double\",\r\n  },\r\n\r\n  // bool\r\n  bool: {\r\n    size: 1,\r\n    category: \"uint\",\r\n    name: \"bool\",\r\n  },\r\n} as const;\r\n\r\nexport const IntsBySize = {\r\n  1: DefaultPrimitives.char,\r\n  2: DefaultPrimitives.short,\r\n  4: DefaultPrimitives.int,\r\n  8: DefaultPrimitives.long,\r\n};\r\nexport const UintsBySize = {\r\n  1: DefaultPrimitives[\"unsigned char\"],\r\n  2: DefaultPrimitives[\"unsigned short\"],\r\n  4: DefaultPrimitives[\"unsigned int\"],\r\n  8: DefaultPrimitives[\"unsigned long\"],\r\n};\r\nexport const FloatsBySize = {\r\n  4: DefaultPrimitives.float,\r\n  8: DefaultPrimitives.double,\r\n};\r\n\r\nexport const DefaultTypes: DefinedTypes = new Map(\r\n  Object.entries(DefaultPrimitives).map(\r\n    ([k, v]) => [k, { ...v, name: k }] as const\r\n  )\r\n);\r\n\r\nexport function execAndRetrieveData(ctx: ExecutionContext, expr: ParseExpr) {\r\n  ctx = expr.exec(ctx);\r\n  return {\r\n    ctx,\r\n    data: ctx.popTempValueAndGetBoth(),\r\n  };\r\n}\r\n\r\nexport function constructTypeFromNode(\r\n  ctx: ExecutionContext,\r\n  node: TypeAnnotationNode\r\n): Type {\r\n  return {\r\n    definition: notNull(\r\n      ctx.types.get(node.d.name),\r\n      `Type '${node.d.name}' does not exist.`,\r\n      ctx\r\n    ),\r\n    pointers: node.d.pointers,\r\n  };\r\n}\r\n", "import { ExecutionError, IdentifierNode, TypeAnnotationNode } from \"./ast\";\r\nimport { Operator, UnaryOperator } from \"./lexing\";\r\nimport { ParseNode } from \"./parser-utils\";\r\nimport {\r\n  DefaultPrimitives,\r\n  FloatsBySize,\r\n  IntsBySize,\r\n  Type,\r\n  TypeDefinition,\r\n} from \"./runtime/runtime\";\r\n\r\nexport class TypecheckContext {\r\n  knownTypeNames: Map<string, TypeDefinition>;\r\n  stack: {\r\n    blocks: { knownVariableTypes: Map<string, Type> }[];\r\n    knownFunctionTypes: Map<\r\n      string,\r\n      {\r\n        args: Type[];\r\n        returns: Type;\r\n      }\r\n    >;\r\n  }[];\r\n\r\n  clone() {\r\n    const tc2 = new TypecheckContext();\r\n    tc2.knownTypeNames = new Map(this.knownTypeNames);\r\n    tc2.stack = this.stack.slice();\r\n  }\r\n\r\n  getTypeFromName(node: TypeAnnotationNode): MaybeType {\r\n    const type = this.knownTypeNames.get(node.d.name);\r\n\r\n    if (type)\r\n      return {\r\n        success: true,\r\n        type: {\r\n          pointers: node.d.pointers,\r\n          definition: type,\r\n        },\r\n      };\r\n\r\n    return {\r\n      success: false,\r\n      why: [{ node, msg: `Type '${node.d.name}' does not exist.` }],\r\n    };\r\n  }\r\n\r\n  getVariableType(node: IdentifierNode): MaybeType {\r\n    const stacktop = this.stacktop();\r\n\r\n    const name = node.d.name;\r\n\r\n    // local vars within function\r\n    for (const block of stacktop.blocks.slice().reverse()) {\r\n      const v = block.knownVariableTypes.get(name);\r\n      if (v) return { type: v, success: true };\r\n    }\r\n\r\n    const v = this.stack[0].blocks[0].knownVariableTypes.get(name);\r\n    if (v) return { type: v, success: true };\r\n\r\n    return {\r\n      success: false,\r\n      why: [{ node, msg: `The variable '${node.d.name}' does not exist.` }],\r\n    };\r\n  }\r\n\r\n  getFunctionTypes(name: string, node: ParseNode<any>) {\r\n    const v = this.stack[0].knownFunctionTypes.get(name);\r\n    if (v) return { success: true as true, ...v };\r\n\r\n    return {\r\n      success: false as false,\r\n      why: [{ node, msg: `The function '${name}' does not exist.` }],\r\n    };\r\n  }\r\n\r\n  stacktop() {\r\n    return this.stack[this.stack.length - 1];\r\n  }\r\n\r\n  blocktop() {\r\n    return this.stacktop().blocks[this.stacktop().blocks.length - 1];\r\n  }\r\n\r\n  withBlock(cb: () => void) {\r\n    this.stacktop().blocks.push({ knownVariableTypes: new Map() });\r\n    cb();\r\n    this.stacktop().blocks.pop();\r\n  }\r\n\r\n  withStackFrame(cb: () => void) {\r\n    this.stack.push({\r\n      blocks: [{ knownVariableTypes: new Map() }],\r\n      knownFunctionTypes: new Map(),\r\n    });\r\n    cb();\r\n    this.stack.pop();\r\n  }\r\n\r\n  defineVariable(name: string, type: Type) {\r\n    this.blocktop().knownVariableTypes.set(name, type);\r\n  }\r\n}\r\n\r\nexport type CTypeError = {\r\n  success: false;\r\n  why: { node: ParseNode<any>; msg: string }[];\r\n};\r\n\r\nexport function typeErr(node: ParseNode<any>, ...msgs: string[]): CTypeError {\r\n  return {\r\n    success: false,\r\n    why: msgs.map((msg) => ({ node, msg })),\r\n  };\r\n}\r\n\r\nexport function typeSuccess(type: Type): { success: true; type: Type } {\r\n  return { success: true as true, type };\r\n}\r\n\r\nexport type MaybeType = { success: true; type: Type } | CTypeError;\r\n\r\nexport interface IParseExpr {\r\n  type(ctx: TypecheckContext): MaybeType;\r\n}\r\n\r\nexport function organizeTypeErrors(\r\n  typeerrors: MaybeType[]\r\n): [CTypeError | undefined, Type[]] {\r\n  const errs = typeerrors.filter((t) => !t.success);\r\n  const successes = typeerrors\r\n    .filter((t) => t.success)\r\n    .map((t) => (t as { success: true; type: Type }).type);\r\n\r\n  if (errs.length === 0) return [undefined, successes];\r\n  return [\r\n    {\r\n      success: false,\r\n      why: errs\r\n        .map((err) => {\r\n          if (err.success) return [];\r\n          return err.why;\r\n        })\r\n        .flat(1),\r\n    },\r\n    successes,\r\n  ];\r\n}\r\n\r\nexport function isStruct(type: Type) {\r\n  return type.definition.category === \"struct\" && type.pointers === 0;\r\n}\r\n\r\nexport function isPointer(type: Type) {\r\n  return type.pointers > 0;\r\n}\r\n\r\nexport function isFloat(type: Type) {\r\n  return type.definition.category === \"float\" && type.pointers === 0;\r\n}\r\n\r\nexport function typeToString(type: Type) {\r\n  let basename = type.definition.name;\r\n\r\n  if (type.definition.category === \"struct\") basename = \"struct \" + basename;\r\n\r\n  return basename + \" \" + \"\".padStart(type.pointers, \"*\");\r\n}\r\n\r\n/*\r\nType checking roles for binary operations:\r\n\r\n- Floats override ints\r\n- Bigger overrides smaller\r\n*/\r\n\r\nexport function combineTypesForArithmetic(\r\n  node: ParseNode<any>,\r\n  a: Type,\r\n  b: Type,\r\n  op: \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\r\n): MaybeType {\r\n  const aPointer = isPointer(a);\r\n  const bPointer = isPointer(b);\r\n\r\n  if (aPointer && bPointer)\r\n    return typeErr(\r\n      node,\r\n      \"Cannot do arithmetic between a pointer and a pointer.\"\r\n    );\r\n\r\n  if (a.definition.category === \"struct\" || b.definition.category === \"struct\")\r\n    return typeErr(node, \"Cannot do arithmetic on structs.\");\r\n\r\n  if (aPointer || bPointer) {\r\n    if (op !== \"+\" && op !== \"-\")\r\n      return typeErr(node, `Cannot do the '${op}' operation with a pointer.`);\r\n  }\r\n\r\n  const biggestSize = Math.max(a.definition.size, b.definition.size) as\r\n    | 8\r\n    | 4\r\n    | 2\r\n    | 1;\r\n  const switchToFloat =\r\n    a.definition.category === \"float\" || b.definition.category === \"float\";\r\n  const switchToSigned =\r\n    a.definition.category === \"int\" || b.definition.category === \"int\";\r\n\r\n  if (switchToFloat) {\r\n    return typeSuccess({\r\n      definition: FloatsBySize[biggestSize as 8 | 4],\r\n      pointers: 0,\r\n    });\r\n  }\r\n\r\n  if (switchToSigned) {\r\n    return typeSuccess({\r\n      definition: IntsBySize[biggestSize],\r\n      pointers: 0,\r\n    });\r\n  }\r\n\r\n  return typeSuccess(a.definition.size === biggestSize ? a : b);\r\n}\r\n\r\nexport function typesEqual(t1: Type, t2: Type) {\r\n  return t1.definition.name === t2.definition.name;\r\n}\r\n\r\nexport function combineTypesForComparisonAndLogical(\r\n  node: ParseNode<any>,\r\n  a: Type,\r\n  b: Type,\r\n  op: \"!=\" | \"==\" | \"<=\" | \"<\" | \">=\" | \">\" | \"&&\" | \"^^\" | \"||\"\r\n) {\r\n  if ((op !== \"!=\" && op !== \"==\" && isStruct(a)) || isStruct(b))\r\n    return typeErr(node, `Cannot use the '${op}' operator on structs.`);\r\n\r\n  return typeSuccess({\r\n    definition: DefaultPrimitives.char,\r\n    pointers: 0,\r\n  });\r\n}\r\n\r\nexport function combineTypesForBitwise(\r\n  node: ParseNode<any>,\r\n  a: Type,\r\n  b: Type,\r\n  op: \"&\" | \"^\" | \"|\" | \"<<\" | \">>\"\r\n) {\r\n  if (isFloat(a) || isFloat(b))\r\n    return typeErr(\r\n      node,\r\n      `Cannot use the '${op}' operator on a floating-point value.`\r\n    );\r\n  if (isPointer(a) || isPointer(b))\r\n    return typeErr(node, `Cannot use the '${op}' operator on pointers.`);\r\n\r\n  // use same promotion and signed/unsigned rules as arithmetic\r\n  return combineTypesForArithmetic(node, a, b, \"+\");\r\n}\r\n\r\nexport function typecheckBinaryOperation(\r\n  ctx: TypecheckContext,\r\n  op: Operator,\r\n  left: IParseExpr & ParseNode<any>,\r\n  right: IParseExpr & ParseNode<any>,\r\n  node: ParseNode<any>\r\n) {\r\n  const mltype = left.type(ctx);\r\n  const mrtype = right.type(ctx);\r\n\r\n  const [errs, [ltype, rtype]] = organizeTypeErrors([mltype, mrtype]);\r\n\r\n  if (errs) return errs;\r\n\r\n  switch (op) {\r\n    // member access\r\n    // TODO: do this later cuz it'll be difficult (maybe remove it due to time constraints)\r\n    case \"->\":\r\n    case \".\":\r\n      return typeErr(node, \"This operation is currently not supported.\");\r\n  }\r\n\r\n  switch (op) {\r\n    // arithmetic operators\r\n    case \"+\":\r\n    case \"-\":\r\n    case \"*\":\r\n    case \"/\":\r\n    case \"%\":\r\n      return combineTypesForArithmetic(node, ltype, rtype, op);\r\n\r\n    // comparison operators\r\n    case \"!=\":\r\n    case \"==\":\r\n    case \"<=\":\r\n    case \">\":\r\n    case \">=\":\r\n    case \"<\":\r\n    case \"&&\":\r\n    case \"^^\":\r\n    case \"||\":\r\n      return combineTypesForComparisonAndLogical(node, ltype, rtype, op);\r\n\r\n    // TODO: disallow bitwise on floats\r\n    // bitwise\r\n    case \"&\":\r\n    case \"^\":\r\n    case \"|\":\r\n    case \"<<\":\r\n    case \">>\":\r\n      return combineTypesForBitwise(node, ltype, rtype, op);\r\n  }\r\n}\r\n\r\nexport function pointerTo(type: Type): Type {\r\n  return {\r\n    definition: type.definition,\r\n    pointers: type.pointers + 1,\r\n  };\r\n}\r\n\r\nexport function dereference(type: Type): Type {\r\n  return {\r\n    definition: type.definition,\r\n    pointers: type.pointers - 1,\r\n  };\r\n}\r\n\r\nexport function typecheckUnaryOperation(\r\n  ctx: TypecheckContext,\r\n  op: UnaryOperator,\r\n  value: IParseExpr & ParseNode<any>,\r\n  node: ParseNode<any>\r\n): MaybeType {\r\n  const mtype = value.type(ctx);\r\n\r\n  const [errs, [type]] = organizeTypeErrors([mtype]);\r\n\r\n  if (errs) return errs;\r\n\r\n  if (op === \"*\") {\r\n    if (!isPointer(type))\r\n      return typeErr(\r\n        node,\r\n        `The '*' operator can only be applied to a pointer type, as it represents the dereferencing of a pointer.`\r\n      );\r\n\r\n    return typeSuccess(dereference(type));\r\n  } else if (op === \"!\") {\r\n    if (isStruct(type))\r\n      return typeErr(\r\n        node,\r\n        `The '!' operator cannot be applied to a struct type.`\r\n      );\r\n\r\n    return typeSuccess({\r\n      definition: DefaultPrimitives.char,\r\n      pointers: 0,\r\n    });\r\n  } else if (op === \"~\") {\r\n    if (isFloat(type))\r\n      return typeErr(\r\n        node,\r\n        `The '~' operator cannot be applied to a floating point type.`\r\n      );\r\n    if (isStruct(type))\r\n      return typeErr(\r\n        node,\r\n        `The '~' operator cannot be applied to a struct type.`\r\n      );\r\n\r\n    return typeSuccess(type);\r\n  }\r\n\r\n  // & operator\r\n  const lv = value.typeLValue(ctx);\r\n  const [errs2, [lvalueType]] = organizeTypeErrors([lv]);\r\n\r\n  if (errs2) return errs2;\r\n\r\n  return typeSuccess(pointerTo(lvalueType));\r\n}\r\n", "import {\r\n  ErrorNode,\r\n  ParseExpr,\r\n  NumberNode,\r\n  IdentifierNode,\r\n  FunctionCallNode,\r\n  BinaryOpNode,\r\n  StatementListNode,\r\n  ParseStatement,\r\n  IfNode,\r\n  FunctionDefNode,\r\n  StructDefinitionNode,\r\n  LoopNode,\r\n  ExecutionError,\r\n  TypeAnnotationNode,\r\n} from \"./ast\";\r\nimport { Operator, UnaryOperator, skipRegex } from \"./lexing\";\r\nimport { ExecutionContext, Type, TypeDefinition } from \"./runtime/runtime\";\r\nimport { CTypeError, MaybeType, TypecheckContext, typeErr } from \"./typecheck\";\r\n\r\nexport type Highlight =\r\n  | \"bracket\"\r\n  | \"operator\"\r\n  | \"identifier\"\r\n  | \"number\"\r\n  | \"comma\"\r\n  | \"semicolon\"\r\n  | \"keyword\"\r\n  | \"type\"\r\n  | \"string\";\r\n\r\nexport type Matcher = string | readonly string[] | RegExp;\r\n\r\nexport interface ParseSource {\r\n  isNext(str: Matcher): string | undefined;\r\n  expect(str: Matcher, highlight: Highlight): [string | undefined, ParseSource];\r\n  match<T>(\r\n    branches: [\r\n      Matcher,\r\n      Highlight,\r\n      (str: string, s: ParseSource) => [T, ParseSource]\r\n    ][],\r\n    fallback: (s: ParseSource) => [T, ParseSource]\r\n  ): [T, ParseSource];\r\n  err(start: ParseSource, msg: string): [ErrorNode, ParseSource];\r\n  bindingPower(): number;\r\n  setBindingPower(bp: number): ParseSource;\r\n  mut(): MutableParseSourceWrapper;\r\n  position(): number;\r\n}\r\n\r\nfunction matchOnString(matcher: Matcher, str: string) {\r\n  if (typeof matcher === \"string\") {\r\n    return str.startsWith(matcher) ? matcher : undefined;\r\n  } else if (Array.isArray(matcher)) {\r\n    for (const matchStr of matcher) {\r\n      if (str.startsWith(matchStr)) return matchStr;\r\n    }\r\n    return undefined;\r\n  } else if (matcher instanceof RegExp) {\r\n    const match = matcher.exec(str);\r\n    if (!match) return undefined;\r\n    if (match.index === 0) return match[0];\r\n  }\r\n}\r\n\r\nexport class ParseInput implements ParseSource {\r\n  src: string;\r\n  pos: number;\r\n  bp: number;\r\n\r\n  position() {\r\n    return this.pos;\r\n  }\r\n\r\n  slice() {\r\n    return this.src.slice(this.pos);\r\n  }\r\n\r\n  constructor(src: string, position: number, bindingPower: number) {\r\n    this.src = src;\r\n    this.bp = bindingPower;\r\n    this.pos = position;\r\n  }\r\n\r\n  isNext(matcher: Matcher) {\r\n    const skipmatch = matchOnString(skipRegex, this.slice());\r\n    const strmatch = matchOnString(\r\n      matcher,\r\n      this.slice().slice(skipmatch?.length ?? 0)\r\n    );\r\n    if (!strmatch) return undefined;\r\n    return strmatch;\r\n  }\r\n\r\n  expect(\r\n    matcher: Matcher,\r\n    highlight: Highlight\r\n  ): [string | undefined, ParseSource] {\r\n    const skipmatch = matchOnString(skipRegex, this.slice());\r\n    const strmatch = matchOnString(\r\n      matcher,\r\n      this.slice().slice(skipmatch?.length ?? 0)\r\n    );\r\n    if (!strmatch) return [undefined, this];\r\n    const len = strmatch.length + (skipmatch?.length ?? 0);\r\n    return [\r\n      strmatch,\r\n      new ParseInput(this.src, this.pos + len, this.bindingPower()),\r\n    ];\r\n  }\r\n\r\n  match<T>(\r\n    branches: [\r\n      Matcher,\r\n      Highlight,\r\n      (str: string, s: ParseSource) => [T, ParseSource]\r\n    ][],\r\n    fallback: (s: ParseSource) => [T, ParseSource]\r\n  ): [T, ParseSource] {\r\n    for (const b of branches) {\r\n      const result = this.expect(b[0], b[1]);\r\n      if (!result[0]) continue;\r\n      return b[2](result[0], result[1]);\r\n    }\r\n    return fallback(this);\r\n  }\r\n\r\n  err(start: ParseSource, msg: string): [ErrorNode, ParseSource] {\r\n    return [new ErrorNode(start, this, { msg }), this];\r\n  }\r\n\r\n  bindingPower(): number {\r\n    return this.bp;\r\n  }\r\n\r\n  setBindingPower(bp: number): ParseSource {\r\n    return new ParseInput(this.src, this.pos, bp);\r\n  }\r\n\r\n  mut(): MutableParseSourceWrapper {\r\n    return new MutableParseInput(this);\r\n  }\r\n}\r\n\r\nexport class MutableParseInput implements MutableParseSourceWrapper {\r\n  src: ParseSource;\r\n\r\n  constructor(src: ParseSource) {\r\n    this.src = src;\r\n  }\r\n\r\n  position() {\r\n    return this.src.position();\r\n  }\r\n\r\n  isNext(matcher: Matcher) {\r\n    return this.src.isNext(matcher);\r\n  }\r\n\r\n  expect(matcher: Matcher, highlight: Highlight) {\r\n    const [result, src] = this.src.expect(matcher, highlight);\r\n    this.src = src;\r\n    return result;\r\n  }\r\n\r\n  match<T>(\r\n    branches: [Matcher, Highlight, (str: string) => T][],\r\n    fallback: () => T\r\n  ) {\r\n    const [result, src] = this.src.match<T>(\r\n      branches.map(\r\n        (b) =>\r\n          [\r\n            b[0],\r\n            b[1],\r\n            (str: string, src: ParseSource) => {\r\n              this.src = src;\r\n              return [b[2](str), this.src];\r\n            },\r\n          ] as [\r\n            Matcher,\r\n            Highlight,\r\n            (str: string, src: ParseSource) => [T, ParseSource]\r\n          ]\r\n      ),\r\n      (src: ParseSource) => {\r\n        this.src = src;\r\n        return [fallback(), this.src];\r\n      }\r\n    );\r\n    this.src = src;\r\n    return result;\r\n  }\r\n\r\n  err(start: ParseSource, msg: string): ErrorNode {\r\n    const [result, src] = this.src.err(start, msg);\r\n    this.src = src;\r\n    return result;\r\n  }\r\n\r\n  bindingPower() {\r\n    return this.src.bindingPower();\r\n  }\r\n\r\n  setBindingPower(bp: number) {\r\n    this.src = this.src.setBindingPower(bp);\r\n  }\r\n\r\n  current() {\r\n    return this.src;\r\n  }\r\n\r\n  parse<PN extends ParseNode<any>>(\r\n    nodetype: (s: ParseSource) => PN,\r\n    bindingPower: number\r\n  ): PN {\r\n    const node = nodetype(this.src.setBindingPower(bindingPower));\r\n    this.src = node.end;\r\n    return node;\r\n  }\r\n}\r\n\r\nexport type MutableParseSourceWrapper = {\r\n  [Key in Exclude<keyof ParseSource, \"match\" | \"setBindingPower\" | \"mut\">]: (\r\n    ...args: Parameters<ParseSource[Key]>\r\n  ) => ReturnType<ParseSource[Key]> extends [infer RetVal, ParseSource]\r\n    ? RetVal\r\n    : ReturnType<ParseSource[Key]>;\r\n} & {\r\n  match<T>(\r\n    branches: [Matcher, Highlight, (str: string) => T][],\r\n    fallback: () => T\r\n  ): T;\r\n  current(): ParseSource;\r\n  parse<PN extends ParseNode<any>>(\r\n    nodetype: (s: ParseSource) => PN,\r\n    bindingPower: number\r\n  ): PN;\r\n  setBindingPower(bp: number): void;\r\n};\r\n\r\nexport type TypeErrorFeedback = { node: ParseNode<any>; msg: string };\r\n\r\nexport abstract class ParseNode<T> {\r\n  d: T;\r\n  start: ParseSource;\r\n  end: ParseSource;\r\n\r\n  constructor(start: ParseSource, end: ParseSource, d: T) {\r\n    this.d = d;\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n\r\n  abstract debug(): string;\r\n\r\n  abstract exec(ctx: ExecutionContext): ExecutionContext;\r\n\r\n  abstract checkInner(\r\n    ctx: TypecheckContext\r\n  ): IterableIterator<TypeErrorFeedback | TypeErrorFeedback[] | undefined>;\r\n\r\n  check(ctx: TypecheckContext): TypeErrorFeedback[] {\r\n    const errors = [...this.checkInner(ctx)].flat();\r\n    return errors.filter((e) => e) as TypeErrorFeedback[];\r\n  }\r\n\r\n  abstract mapInner(callback: (node: ParseNode<any>) => void): void;\r\n\r\n  map(callback: (node: ParseNode<any>) => void) {\r\n    callback(this);\r\n\r\n    this.mapInner(callback);\r\n  }\r\n\r\n  // lvalues are treated as pointers to whatever they're being assigned to\r\n  execLValue(ctx: ExecutionContext): ExecutionContext {\r\n    throw new ExecutionError(\r\n      `This expression cannot be used as an lvalue.`,\r\n      ctx\r\n    );\r\n  }\r\n\r\n  setBindingPower(bp: number) {\r\n    // @ts-expect-error\r\n    return new this.constructor(\r\n      this.start,\r\n      this.end.setBindingPower(bp),\r\n      this.d\r\n    );\r\n  }\r\n\r\n  setParserPointer(pp: ParseSource) {\r\n    this.end = pp;\r\n    return this;\r\n  }\r\n\r\n  typeLValue(ctx: TypecheckContext): MaybeType {\r\n    return typeErr(\r\n      this,\r\n      \"This cannot be used as an lvalue (thing that can be assigned to).\"\r\n    );\r\n  }\r\n\r\n  checkLValue(ctx: TypecheckContext): TypeErrorFeedback[] {\r\n    const result = this.typeLValue(ctx);\r\n    if (result.success) return [];\r\n    return result.why;\r\n  }\r\n}\r\n\r\nfunction isExpr(stmt: any): stmt is ParseExpr {\r\n  return (\r\n    stmt instanceof ErrorNode ||\r\n    stmt instanceof NumberNode ||\r\n    stmt instanceof IdentifierNode ||\r\n    stmt instanceof FunctionCallNode ||\r\n    stmt instanceof BinaryOpNode ||\r\n    stmt instanceof StatementListNode\r\n  );\r\n}\r\n\r\nexport function requiresSemicolon(stmt: ParseStatement) {\r\n  return !(\r\n    stmt instanceof IfNode ||\r\n    stmt instanceof FunctionDefNode ||\r\n    stmt instanceof StructDefinitionNode ||\r\n    stmt instanceof LoopNode\r\n  );\r\n}\r\n\r\nexport const BindingPowers: { [Key in Operator]: number } = {\r\n  // logical\r\n  \"||\": 40,\r\n  \"^^\": 50,\r\n  \"&&\": 60,\r\n\r\n  // bitwise\r\n  \"|\": 70,\r\n  \"^\": 80,\r\n  \"&\": 90,\r\n\r\n  // comparison\r\n  \"==\": 100,\r\n  \"!=\": 100,\r\n  \">=\": 110,\r\n  \"<=\": 110,\r\n  \">\": 110,\r\n  \"<\": 110,\r\n\r\n  // bitshift\r\n  \">>\": 120,\r\n  \"<<\": 120,\r\n\r\n  // arithmetic\r\n  \"+\": 130,\r\n  \"-\": 130,\r\n  \"*\": 140,\r\n  \"/\": 140,\r\n  \"%\": 140,\r\n\r\n  // member access\r\n  \".\": 160,\r\n  \"->\": 160,\r\n};\r\n\r\nexport const UnaryBindingPowers: { [key in UnaryOperator]: number } = {\r\n  // unaries\r\n  \"*\": 150,\r\n  \"&\": 150,\r\n  \"~\": 150,\r\n  \"!\": 150,\r\n};\r\n", "import { ExecutionError, ParseExpr, automap, defaultExprCheck } from \"../ast\";\r\nimport { Operator } from \"../lexing\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport {\r\n  IParseExpr,\r\n  TypecheckContext,\r\n  typecheckBinaryOperation,\r\n} from \"../typecheck\";\r\n\r\nexport function handleBinaryOperation(ctx: ExecutionContext, op: Operator) {\r\n  const right = ctx.popTempValueAndGetBoth();\r\n  const left = ctx.popTempValueAndGetBoth();\r\n\r\n  let lv = left.value;\r\n  let rv = right.value;\r\n\r\n  switch (op) {\r\n    // member access\r\n    // TODO: do this later cuz it'll be difficult\r\n    case \"->\":\r\n    case \".\":\r\n      return ctx;\r\n  }\r\n\r\n  if (lv instanceof ArrayBuffer || rv instanceof ArrayBuffer) {\r\n    throw new ExecutionError(\"Cannot do this operation between structs\", ctx);\r\n  }\r\n\r\n  // get rid of bigints if either operand is floating-point\r\n  if (\r\n    left.typeinfo.type.definition.category === \"float\" ||\r\n    right.typeinfo.type.definition.category === \"float\"\r\n  ) {\r\n    lv = Number(lv);\r\n    rv = Number(rv);\r\n    // otherwise convert both to bigint, cuz they're both ints and that's fine\r\n  } else {\r\n    lv = BigInt(lv);\r\n    rv = BigInt(rv);\r\n  }\r\n\r\n  let output;\r\n\r\n  // TODO: implement horrible C typecasting rules\r\n  let outputType = left.typeinfo.type;\r\n\r\n  // pointer arithmetic weirdness with + and -\r\n  if (\r\n    (op === \"+\" || op === \"-\") &&\r\n    (left.typeinfo.type.pointers > 0 || right.typeinfo.type.pointers > 0)\r\n  ) {\r\n    rv = Number(rv);\r\n    lv = Number(lv);\r\n\r\n    // is the left arg the pointer\r\n    const leftIsPtr = left.typeinfo.type.pointers > 0;\r\n\r\n    // multply right value by -1\r\n    if (op === \"-\") {\r\n      rv *= -1;\r\n    }\r\n\r\n    // pointer value and non-pointer value\r\n    const ptrVal = leftIsPtr ? lv : rv;\r\n    const nonPtrVal = leftIsPtr ? rv : lv;\r\n\r\n    // pointer type and non-pointer type\r\n    const ptrType = leftIsPtr ? left.typeinfo : right.typeinfo;\r\n    const nonPtrType = leftIsPtr ? right.typeinfo : left.typeinfo;\r\n\r\n    // do pointer arithmetic and figure out output type\r\n    output =\r\n      ptrVal +\r\n      nonPtrVal *\r\n        ctx.sizeof({\r\n          definition: ptrType.type.definition,\r\n          pointers: ptrType.type.pointers - 1,\r\n        });\r\n    outputType = ptrType.type;\r\n\r\n    // push to stack\r\n    ctx.pushAnonymous(outputType, output);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  switch (op) {\r\n    // arithmetic operators\r\n    case \"+\":\r\n    case \"-\":\r\n    case \"*\":\r\n    case \"/\":\r\n    case \"%\":\r\n      output = {\r\n        \"+\": (a, b) => a + b,\r\n        \"-\": (a, b) => a - b,\r\n        \"*\": (a, b) => a * b,\r\n        \"/\": (a, b) => a / b,\r\n        \"%\": (a, b) => a % b,\r\n      }[op](lv, rv);\r\n      break;\r\n\r\n    // comparison operators\r\n    case \"!=\":\r\n    case \"==\":\r\n    case \"<=\":\r\n    case \">\":\r\n    case \">=\":\r\n    case \"<\":\r\n    case \"&&\":\r\n    case \"^^\":\r\n    case \"||\":\r\n      output = Number(\r\n        {\r\n          \"==\": (a, b) => a == b,\r\n          \"!=\": (a, b) => a != b,\r\n          \">=\": (a, b) => a >= b,\r\n          \">\": (a, b) => a > b,\r\n          \"<=\": (a, b) => a <= b,\r\n          \"<\": (a, b) => a < b,\r\n        }[op](lv, rv)\r\n      );\r\n      break;\r\n\r\n    // TODO: disallow bitwise on floats\r\n    // bitwise\r\n    case \"&\":\r\n    case \"^\":\r\n    case \"|\":\r\n    case \"<<\":\r\n    case \">>\":\r\n      output = {\r\n        \"&\": (a, b) => a & b,\r\n        \"^\": (a, b) => a ^ b,\r\n        \"|\": (a, b) => a | b,\r\n        \">>\": (a, b) => a >> b,\r\n        \"<<\": (a, b) => a << b,\r\n      }[op](lv, rv);\r\n      break;\r\n  }\r\n\r\n  if (output !== undefined) {\r\n    ctx.pushAnonymous(outputType, output);\r\n  }\r\n\r\n  return ctx;\r\n}\r\n\r\nexport class BinaryOpNode\r\n  extends ParseNode<{\r\n    left: ParseExpr;\r\n    right: ParseExpr;\r\n    op: Operator;\r\n  }>\r\n  implements IParseExpr\r\n{\r\n  debug(): string {\r\n    return `(${this.d.op} ${this.d.left.debug()} ${this.d.right.debug()})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n    ctx = this.d.left.exec(ctx);\r\n    ctx = this.d.right.exec(ctx);\r\n\r\n    ctx = handleBinaryOperation(ctx, this.d.op);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  // TODO: Implement lvalues here later\r\n\r\n  mapInner(cb: (node: ParseNode<any>) => void): void {\r\n    automap(this.d.left, cb);\r\n    automap(this.d.right, cb);\r\n  }\r\n\r\n  type(ctx: TypecheckContext) {\r\n    return typecheckBinaryOperation(\r\n      ctx,\r\n      this.d.op,\r\n      this.d.left,\r\n      this.d.right,\r\n      this\r\n    );\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import { ParseExpr, automap } from \"../ast\";\r\nimport { Operator } from \"../lexing\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { organizeTypeErrors } from \"../typecheck\";\r\nimport { handleBinaryOperation } from \"./BinaryOpNode\";\r\n\r\nexport class AssignmentNode extends ParseNode<{\r\n  left: ParseExpr;\r\n  right: ParseExpr;\r\n  op?: Operator;\r\n}> {\r\n  debug(): string {\r\n    return `(${\r\n      this.d.op ?? \"\"\r\n    }= ${this.d.left.debug()} ${this.d.right.debug()})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    ctx = this.d.left.execLValue(ctx);\r\n\r\n    if (this.d.op) {\r\n      ctx = this.d.left.exec(ctx);\r\n    }\r\n\r\n    ctx = this.d.right.exec(ctx);\r\n\r\n    if (this.d.op) {\r\n      handleBinaryOperation(ctx, this.d.op);\r\n    }\r\n\r\n    const right = ctx.popTempValueAndGetBoth();\r\n\r\n    // must be a pointer to the thing to be assigned to\r\n    const left = ctx.popTempValueAndGetBoth();\r\n\r\n    ctx.setVar(\r\n      {\r\n        type: right.typeinfo.type,\r\n        offset: left.value as number,\r\n      },\r\n      right.value\r\n    );\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.left, cb);\r\n    automap(this.d.right, cb);\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    const mltype = this.d.left.typeLValue(ctx);\r\n    const mrtype = this.d.right.type(ctx);\r\n\r\n    const [errs, [ltype, rtype]] = organizeTypeErrors([mltype, mrtype]);\r\n\r\n    yield errs?.why;\r\n\r\n    // TODO: ensure that rtype is assignable to ltype\r\n  }\r\n}\r\n", "import { ExecutionError, defaultExprCheck } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { IParseExpr, TypecheckContext, MaybeType } from \"../typecheck\";\r\n\r\nexport class ErrorNode\r\n  extends ParseNode<{ msg: string }>\r\n  implements IParseExpr\r\n{\r\n  debug() {\r\n    return `(#ERROR# '${this.d.msg}')`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    throw new ExecutionError(`Parse Error: ${this.d.msg}`, ctx);\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {}\r\n\r\n  type(ctx: TypecheckContext): MaybeType {\r\n    return { success: false, why: [{ node: this, msg: this.d.msg }] };\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import { ParseExpr, ExecutionError, automap, defaultExprCheck } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport {\r\n  IParseExpr,\r\n  TypecheckContext,\r\n  MaybeType,\r\n  organizeTypeErrors,\r\n  isStruct,\r\n  typeToString,\r\n} from \"../typecheck\";\r\n\r\nexport class FunctionCallNode\r\n  extends ParseNode<{\r\n    args: ParseExpr[];\r\n    name: string;\r\n  }>\r\n  implements IParseExpr\r\n{\r\n  debug(): string {\r\n    return `(${this.d.name} ${this.d.args\r\n      .map((arg) => arg.debug())\r\n      .join(\" \")})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n    for (const arg of this.d.args) {\r\n      ctx = arg.exec(ctx);\r\n    }\r\n\r\n    const fndef = ctx.getFunctionDefinition(this.d.name);\r\n\r\n    if (!fndef) {\r\n      console.log(ctx);\r\n      throw new ExecutionError(`Function '${fndef}' does not exist.`, ctx);\r\n    }\r\n\r\n    if (fndef.type === \"internal\") {\r\n      ctx = fndef.def.call(ctx);\r\n    } else {\r\n      ctx = fndef.def(ctx, this.d.args);\r\n    }\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.args, cb);\r\n  }\r\n\r\n  type(ctx: TypecheckContext): MaybeType {\r\n    const functionTypeSig = ctx.getFunctionTypes(this.d.name, this);\r\n\r\n    if (!functionTypeSig.success) return functionTypeSig;\r\n\r\n    // correct number of args\r\n    if (functionTypeSig.args.length !== this.d.args.length)\r\n      return {\r\n        success: false,\r\n        why: [\r\n          {\r\n            node: this,\r\n            msg: `The function '${this.d.name}' takes ${functionTypeSig.args.length} arguments, but you supplied ${this.d.args.length} arguments.`,\r\n          },\r\n        ],\r\n      };\r\n\r\n    const maybeArgTypes: MaybeType[] = this.d.args.map((arg) => arg.type(ctx));\r\n\r\n    const [errs, argTypes] = organizeTypeErrors(maybeArgTypes);\r\n\r\n    if (errs) return errs;\r\n\r\n    const badargs: string[] = [];\r\n\r\n    for (let i = 0; i < functionTypeSig.args.length; i++) {\r\n      // only strictly match if both are structs\r\n      if (!isStruct(argTypes[i]) && !isStruct(functionTypeSig[i])) continue;\r\n\r\n      if (argTypes[i].definition !== functionTypeSig[i].definition)\r\n        badargs.push(\r\n          `Argument ${i + 1} should be of type '${typeToString(\r\n            argTypes[i]\r\n          )}', but you put '${typeToString(functionTypeSig[i])}'.`\r\n        );\r\n    }\r\n\r\n    return { type: functionTypeSig.returns, success: true };\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import {\r\n  ParseStatement,\r\n  ExecutionError,\r\n  automap,\r\n  handleStatementList,\r\n} from \"../ast\";\r\nimport { ParseNode, TypeErrorFeedback } from \"../parser-utils\";\r\nimport { ExecutionContext, StackFrame } from \"../runtime/runtime\";\r\nimport { DefinitionNode } from \"./DefinitionNode\";\r\n\r\nexport class FunctionDefNode extends ParseNode<{\r\n  args: DefinitionNode[];\r\n  returnTypeAndName: DefinitionNode;\r\n  body: ParseStatement[];\r\n}> {\r\n  debug(): string {\r\n    return `(fndef ${this.d.args\r\n      .map((arg) => `(${arg.debug()})`)\r\n      .join(\" \")} ${this.d.body.map((v) => v.debug()).join(\" \")})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx.addFunctionDefinition(this.d.returnTypeAndName.d.name, this);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  call(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    const ret = ctx.types.get(this.d.returnTypeAndName.d.type.d.name);\r\n\r\n    if (!ret)\r\n      throw new ExecutionError(\r\n        `Return type '${this.d.returnTypeAndName.d.type.d.name}' does not exist.`,\r\n        ctx\r\n      );\r\n\r\n    const frame: StackFrame = {\r\n      base: ctx.esp,\r\n      bindings: new Map(),\r\n      temporaries: [],\r\n      functionDefinitions: new Map(),\r\n      freed: false,\r\n      returnType: {\r\n        definition: ret,\r\n        pointers: this.d.returnTypeAndName.d.type.d.pointers,\r\n      },\r\n      argc: this.d.args.length,\r\n      blocks: [\r\n        {\r\n          bindings: new Map(),\r\n        },\r\n      ],\r\n    };\r\n\r\n    let offset = 0;\r\n\r\n    // assign bindings to args in reverse order\r\n    // to so the last one is first\r\n    for (const arg of this.d.args.slice().reverse()) {\r\n      const type = ctx.types.get(arg.d.type.d.name);\r\n\r\n      if (!type)\r\n        throw new ExecutionError(\r\n          `Error with argument '${arg.d.name}': Type '${arg.d.type.d.name}' does not exist.`,\r\n          ctx\r\n        );\r\n\r\n      const fnargType = {\r\n        definition: type,\r\n        pointers: arg.d.type.d.pointers,\r\n      };\r\n\r\n      offset += ctx.sizeof(fnargType);\r\n\r\n      frame.bindings.set(arg.d.name, {\r\n        offset: ctx.esp - offset,\r\n        type: fnargType,\r\n        name: arg.d.name,\r\n      });\r\n    }\r\n\r\n    ctx.stack.push(frame);\r\n\r\n    ctx = handleStatementList(ctx, this.d.body).ctx;\r\n\r\n    if (!frame.freed) {\r\n      ctx = ctx.clone();\r\n      ctx.popStackFrame();\r\n    }\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.args, cb);\r\n    automap(this.d.returnTypeAndName, cb);\r\n    automap(this.d.body, cb);\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    const checks: TypeErrorFeedback[] = [];\r\n    ctx.withStackFrame(() => {\r\n      // typecheck fnargs\r\n      for (const stmt of this.d.args) checks.push(...stmt.check(ctx));\r\n    });\r\n    yield checks;\r\n  }\r\n}\r\n", "import { ExecutionError, defaultExprCheck } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { IParseExpr, TypecheckContext, MaybeType } from \"../typecheck\";\r\n\r\nexport class IdentifierNode\r\n  extends ParseNode<{ name: string }>\r\n  implements IParseExpr\r\n{\r\n  debug(): string {\r\n    return this.d.name;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    const data = ctx.getvar(this.d.name);\r\n\r\n    if (!data) {\r\n      throw new ExecutionError(\r\n        `Identifier '${this.d.name}' does not exist.`,\r\n        ctx\r\n      );\r\n    }\r\n\r\n    ctx.pushAnonymous(data.type, ctx.getVar(data));\r\n\r\n    return ctx;\r\n  }\r\n\r\n  execLValue(ctx: ExecutionContext): ExecutionContext {\r\n    ctx = ctx.clone();\r\n\r\n    const data = ctx.getvar(this.d.name);\r\n\r\n    if (!data) {\r\n      throw new ExecutionError(\r\n        `Identifier '${this.d.name}' does not exist.`,\r\n        ctx\r\n      );\r\n    }\r\n\r\n    ctx.pushAnonymous(\r\n      {\r\n        definition: data.type.definition,\r\n        pointers: data.type.pointers + 1,\r\n      },\r\n      data.offset\r\n    );\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner() {}\r\n\r\n  type(ctx: TypecheckContext): MaybeType {\r\n    return ctx.getVariableType(this);\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import {\r\n  ParseExpr,\r\n  ParseStatement,\r\n  autodebug,\r\n  automap,\r\n  handleStatementList,\r\n} from \"../ast\";\r\nimport { ParseNode, TypeErrorFeedback } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypecheckContext } from \"../typecheck\";\r\nimport { ElseNode } from \"./ElseNode\";\r\n\r\nexport class IfNode extends ParseNode<{\r\n  condition: ParseExpr;\r\n  body: ParseStatement[];\r\n  elseif?: IfNode | ElseNode;\r\n}> {\r\n  debug(): string {\r\n    return `(if ${this.d.condition.debug()} (${autodebug(this.d.body)}) ${\r\n      this.d.elseif ? `else ${autodebug(this.d.elseif)}` : \"\"\r\n    })`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    ctx = this.d.condition.exec(ctx);\r\n\r\n    const top = ctx.popTempValueAndGetData();\r\n\r\n    // top is 0 --> go to else\r\n    if (top == 0) {\r\n      ctx = this.d.elseif?.exec(ctx) ?? ctx;\r\n\r\n      // top is non-0 --> execute this\r\n    } else {\r\n      ctx = handleStatementList(ctx, this.d.body).ctx;\r\n    }\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.condition, cb);\r\n    automap(this.d.body, cb);\r\n    automap(this.d.elseif, cb);\r\n  }\r\n\r\n  *checkInner(ctx: TypecheckContext) {\r\n    yield this.d.condition.check(ctx);\r\n    const checks: TypeErrorFeedback[] = [];\r\n    ctx.withBlock(() => {\r\n      for (const stmt of this.d.body) checks.push(...stmt.check(ctx));\r\n    });\r\n    yield checks;\r\n    yield this.d.elseif?.check(ctx);\r\n  }\r\n}\r\n", "import {\r\n  ParseStatement,\r\n  ParseExpr,\r\n  autodebug,\r\n  automap,\r\n  handleStatementList,\r\n} from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\n\r\nexport class LoopNode extends ParseNode<{\r\n  body: ParseStatement[];\r\n  conditions:\r\n    | {\r\n        type: \"for\";\r\n        start?: ParseStatement;\r\n        condition?: ParseExpr;\r\n        iter?: ParseStatement;\r\n      }\r\n    | {\r\n        type: \"while\";\r\n        condition: ParseExpr;\r\n      };\r\n}> {\r\n  debug(): string {\r\n    if (this.d.conditions.type === \"for\") {\r\n      return `(for (${autodebug(this.d.conditions.start)} ${autodebug(\r\n        this.d.conditions.condition\r\n      )} ${autodebug(this.d.conditions.iter)}) ${autodebug(this.d.body)})`;\r\n    } else {\r\n      return `(while ${this.d.conditions.condition.debug()} ${autodebug(\r\n        this.d.body\r\n      )})`;\r\n    }\r\n  }\r\n\r\n  // TODO: deal with stack misalignment from statements that contain expressions but don't do anything with them\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    const stacktop = ctx.stacktop();\r\n\r\n    const end = () => {\r\n      ctx.popBlock();\r\n      return ctx;\r\n    };\r\n\r\n    // while loop\r\n    if (this.d.conditions.type === \"while\") {\r\n      ctx.pushBlock();\r\n      while (true) {\r\n        ctx = this.d.conditions.condition.exec(ctx);\r\n\r\n        const cond = ctx.popTempValueAndGetBoth();\r\n\r\n        if (cond.value == 0) {\r\n          break;\r\n        }\r\n\r\n        const list = handleStatementList(ctx, this.d.body);\r\n\r\n        ctx = list.ctx;\r\n\r\n        if (list.returned) return ctx;\r\n      }\r\n\r\n      // for loop\r\n    } else {\r\n      ctx = this.d.conditions.start?.exec(ctx) ?? ctx;\r\n      if (stacktop.freed) return ctx;\r\n\r\n      while (true) {\r\n        ctx = this.d.conditions.condition?.exec(ctx) ?? ctx;\r\n        if (stacktop.freed) return ctx;\r\n\r\n        const cond = this.d.conditions.condition\r\n          ? ctx.popTempValueAndGetBoth()\r\n          : undefined;\r\n\r\n        if (cond && cond.value == 0) break;\r\n\r\n        const list = handleStatementList(ctx, this.d.body);\r\n        ctx = list.ctx;\r\n        if (list.returned) return ctx;\r\n\r\n        ctx = this.d.conditions.iter?.exec(ctx) ?? ctx;\r\n\r\n        if (stacktop.freed) return ctx;\r\n      }\r\n    }\r\n\r\n    return end();\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.body, cb);\r\n\r\n    if (this.d.conditions.type === \"while\") {\r\n      automap(this.d.conditions.condition, cb);\r\n    } else {\r\n      automap(this.d.conditions.condition, cb);\r\n      automap(this.d.conditions.iter, cb);\r\n      automap(this.d.conditions.start, cb);\r\n    }\r\n  }\r\n\r\n  // TODO: impl this\r\n  *checkInner(ctx) {}\r\n}\r\n", "import { defaultExprCheck } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport {\r\n  FloatsBySize,\r\n  UintsBySize,\r\n  IntsBySize,\r\n  ExecutionContext,\r\n} from \"../runtime/runtime\";\r\nimport { IParseExpr, TypecheckContext, MaybeType } from \"../typecheck\";\r\n\r\nexport class NumberNode\r\n  extends ParseNode<{\r\n    num: number;\r\n    type: \"f\" | \"u\" | \"i\";\r\n    bytes?: number;\r\n  }>\r\n  implements IParseExpr\r\n{\r\n  debug() {\r\n    return this.d.num.toString();\r\n  }\r\n\r\n  determineNumericType() {\r\n    const bytes = this.d.bytes ?? (this.d.type === \"f\" ? 8 : 4);\r\n    switch (this.d.type) {\r\n      case \"f\":\r\n        return {\r\n          definition: FloatsBySize[bytes],\r\n          pointers: 0,\r\n        };\r\n      case \"u\":\r\n        return {\r\n          definition: UintsBySize[bytes],\r\n          pointers: 0,\r\n        };\r\n      case \"i\":\r\n      default:\r\n        return {\r\n          definition: IntsBySize[bytes],\r\n          pointers: 0,\r\n        };\r\n    }\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    const ctx2 = ctx.clone();\r\n\r\n    // default to 32-bit temp values\r\n    ctx2.pushAnonymous(this.determineNumericType(), this.d.num);\r\n\r\n    return ctx2;\r\n  }\r\n\r\n  mapInner() {}\r\n\r\n  type(ctx: TypecheckContext): MaybeType {\r\n    return {\r\n      success: true,\r\n      type: this.determineNumericType(),\r\n    };\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import { ParseExpr, autodebug, automap } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\n\r\nexport class ReturnStatementNode extends ParseNode<{\r\n  expr?: ParseExpr;\r\n}> {\r\n  debug(): string {\r\n    return `(return ${autodebug(this.d.expr)})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    ctx = this.d.expr?.exec(ctx) ?? ctx;\r\n\r\n    let outputValue: number | bigint | ArrayBuffer = 0;\r\n\r\n    if (this.d.expr) {\r\n      const output = ctx.popTempValueAndGetBoth();\r\n      outputValue = output.value;\r\n    }\r\n\r\n    const frame = ctx.popStackFrame();\r\n\r\n    ctx.pushAnonymous(frame.returnType, outputValue);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb: (node: ParseNode<any>) => void): void {\r\n    automap(this.d.expr, cb);\r\n  }\r\n\r\n  // TODO: statically ensure that return type matches enclosing function type\r\n\r\n  *checkInner(ctx) {\r\n    if (this.d.expr) yield this.d.expr.check(ctx);\r\n  }\r\n}\r\n", "import { ParseStatement, automap, handleStatementList } from \"../ast\";\r\nimport { ParseNode, TypeErrorFeedback } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypecheckContext } from \"../typecheck\";\r\n\r\nexport class StatementListNode extends ParseNode<{\r\n  body: ParseStatement[];\r\n}> {\r\n  debug(): string {\r\n    return this.d.body.map((s) => s.debug()).join(\"\\n\");\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    ctx = handleStatementList(ctx, this.d.body).ctx;\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb: (node: ParseNode<any>) => void): void {\r\n    automap(this.d.body, cb);\r\n  }\r\n\r\n  *checkInner(\r\n    ctx: TypecheckContext\r\n  ): IterableIterator<TypeErrorFeedback | TypeErrorFeedback[] | undefined> {\r\n    for (const stmt of this.d.body) yield stmt.check(ctx);\r\n  }\r\n}\r\n", "import { defaultExprCheck } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext, DefaultPrimitives } from \"../runtime/runtime\";\r\nimport { IParseExpr, TypecheckContext, typeSuccess } from \"../typecheck\";\r\n\r\nexport class StringLiteralNode\r\n  extends ParseNode<{\r\n    str: string;\r\n    pointer: number;\r\n  }>\r\n  implements IParseExpr\r\n{\r\n  debug() {\r\n    return `${JSON.stringify(this.d.str)}`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    ctx.pushAnonymous(this._type(), this.d.pointer);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(callback: (node: ParseNode<any>) => void): void {}\r\n\r\n  _type() {\r\n    return {\r\n      definition: DefaultPrimitives.char,\r\n      pointers: 1,\r\n    };\r\n  }\r\n\r\n  type(ctx: TypecheckContext) {\r\n    return typeSuccess(this._type());\r\n  }\r\n\r\n  *checkInner(\r\n    ctx: TypecheckContext\r\n  ): IterableIterator<\r\n    | { node: ParseNode<any>; msg: string }\r\n    | { node: ParseNode<any>; msg: string }[]\r\n  > {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import { autodebug, ExecutionError, automap } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypecheckContext } from \"../typecheck\";\r\nimport { DefinitionNode } from \"./DefinitionNode\";\r\n\r\nexport class StructDefinitionNode extends ParseNode<{\r\n  name: string;\r\n  fields: DefinitionNode[];\r\n}> {\r\n  debug(): string {\r\n    return `(struct ${this.d.name} (${autodebug(this.d.fields)}))`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    // TODO: cehck if types and fieldtypes exist and decide what to do\r\n\r\n    ctx.types.set(this.d.name, {\r\n      category: \"struct\",\r\n      name: this.d.name,\r\n      fields: this.d.fields.map((f) => {\r\n        const fieldtype = ctx.types.get(f.d.type.d.name);\r\n\r\n        if (!fieldtype)\r\n          throw new ExecutionError(\r\n            `The struct field '${f.d.name}' has type '${f.d.type}', which does not exist.`,\r\n            ctx\r\n          );\r\n\r\n        return [\r\n          f.d.name,\r\n          {\r\n            definition: fieldtype,\r\n            pointers: f.d.type.d.pointers,\r\n          },\r\n        ];\r\n      }),\r\n    });\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.fields, cb);\r\n  }\r\n\r\n  *checkInner(ctx: TypecheckContext) {}\r\n}\r\n", "import { ParseExpr, automap, defaultExprCheck } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport {\r\n  ExecutionContext,\r\n  execAndRetrieveData,\r\n  constructTypeFromNode,\r\n} from \"../runtime/runtime\";\r\nimport { IParseExpr, TypecheckContext } from \"../typecheck\";\r\nimport { TypeAnnotationNode } from \"./TypeAnnotationNode\";\r\n\r\nexport class TypecastNode\r\n  extends ParseNode<{\r\n    type: TypeAnnotationNode;\r\n    value: ParseExpr;\r\n  }>\r\n  implements IParseExpr\r\n{\r\n  debug(): string {\r\n    return `(cast ${this.d.value.debug()} to ${this.d.type.debug()})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    const data = execAndRetrieveData(ctx, this.d.value);\r\n    ctx = data.ctx;\r\n\r\n    const type = constructTypeFromNode(ctx, this.d.type);\r\n    ctx.pushAnonymous(type, data.data.value);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.type, cb);\r\n    automap(this.d.value, cb);\r\n  }\r\n\r\n  type(ctx: TypecheckContext) {\r\n    const type = ctx.getTypeFromName(this.d.type);\r\n    return type;\r\n  }\r\n\r\n  *checkInner(\r\n    ctx: TypecheckContext\r\n  ): IterableIterator<\r\n    | { node: ParseNode<any>; msg: string }\r\n    | { node: ParseNode<any>; msg: string }[]\r\n  > {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n}\r\n", "import { ParseExpr, automap, defaultExprCheck } from \"../ast\";\r\nimport { UnaryOperator } from \"../lexing\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext, DefaultPrimitives } from \"../runtime/runtime\";\r\nimport {\r\n  IParseExpr,\r\n  MaybeType,\r\n  TypecheckContext,\r\n  typeErr,\r\n  typecheckUnaryOperation,\r\n} from \"../typecheck\";\r\n\r\nexport class UnaryOpNode\r\n  extends ParseNode<{\r\n    value: ParseExpr;\r\n    op: UnaryOperator;\r\n  }>\r\n  implements IParseExpr\r\n{\r\n  debug(): string {\r\n    return `(${this.d.op} ${this.d.value.debug()})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n    ctx =\r\n      this.d.op === \"&\" ? this.d.value.execLValue(ctx) : this.d.value.exec(ctx);\r\n\r\n    const value = ctx.popTempValueAndGetBoth();\r\n\r\n    let output;\r\n\r\n    let outputType;\r\n\r\n    // TODO: disallow float with bitwise\r\n\r\n    switch (this.d.op) {\r\n      case \"!\":\r\n        output = value.value == 0 ? 1 : 0;\r\n        outputType = DefaultPrimitives.bool;\r\n        break;\r\n      case \"&\":\r\n        output = value.value;\r\n        outputType = {\r\n          ...value.typeinfo.type,\r\n          pointers: value.typeinfo.type.pointers + 1,\r\n        };\r\n        break;\r\n      case \"*\":\r\n        outputType = {\r\n          ...value.typeinfo.type,\r\n          pointers: value.typeinfo.type.pointers - 1,\r\n        };\r\n        output = ctx.getVar({\r\n          offset: Number(value.value),\r\n          type: outputType,\r\n        });\r\n        break;\r\n      case \"~\":\r\n        output = ~value.value;\r\n        outputType = value.typeinfo.type;\r\n        break;\r\n    }\r\n\r\n    ctx.pushAnonymous(outputType, output);\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.value, cb);\r\n  }\r\n\r\n  type(ctx: TypecheckContext) {\r\n    return typecheckUnaryOperation(ctx, this.d.op, this.d.value, this);\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    return defaultExprCheck(this, ctx);\r\n  }\r\n\r\n  typeLValue(ctx: TypecheckContext): MaybeType {\r\n    if (this.d.op !== \"*\") {\r\n      return typeErr(this, `This expression cannot be an lvalue.`);\r\n    }\r\n\r\n    // typecheck dereference operator as normal\r\n    return typecheckUnaryOperation(ctx, this.d.op, this.d.value, this);\r\n  }\r\n}\r\n", "import {\r\n  DefinitionNode,\r\n  ParseExpr,\r\n  ExecutionError,\r\n  automap,\r\n  autodebug,\r\n} from \"../ast\";\r\nimport { ParseNode, TypeErrorFeedback } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypecheckContext, organizeTypeErrors } from \"../typecheck\";\r\n\r\nexport class VariableDefinitionNode extends ParseNode<{\r\n  definition: DefinitionNode;\r\n  value?: ParseExpr;\r\n}> {\r\n  debug(): string {\r\n    return `(let ${this.d.definition.debug()} ${autodebug(this.d.value)})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    const typeOfThisVar = ctx.types.get(this.d.definition.d.type.d.name);\r\n\r\n    if (!typeOfThisVar)\r\n      throw new ExecutionError(\r\n        `The type '${this.d.definition.d.type.d.name}' does not exist.`,\r\n        ctx\r\n      );\r\n\r\n    let value: number | bigint | ArrayBuffer = 0;\r\n\r\n    // TODO: check to see whether types properly match\r\n    if (this.d.value) {\r\n      ctx = this.d.value.exec(ctx);\r\n      const thingToAssign = ctx.popTempValueAndGetBoth();\r\n      value = thingToAssign.value;\r\n    }\r\n\r\n    ctx.pushNamed(\r\n      {\r\n        definition: typeOfThisVar,\r\n        pointers: this.d.definition.d.type.d.pointers,\r\n      },\r\n      value,\r\n      this.d.definition.d.name\r\n    );\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.definition, cb);\r\n    automap(this.d.value, cb);\r\n  }\r\n\r\n  *checkInner(\r\n    ctx: TypecheckContext\r\n  ): IterableIterator<TypeErrorFeedback | TypeErrorFeedback[] | undefined> {\r\n    yield this.d.definition.check(ctx);\r\n    yield this.d.value?.check(ctx);\r\n\r\n    const [fail, [type]] = organizeTypeErrors([\r\n      ctx.getTypeFromName(this.d.definition.d.type),\r\n    ]);\r\n\r\n    yield fail?.why;\r\n\r\n    ctx.defineVariable(this.d.definition.d.name, type);\r\n  }\r\n}\r\n", "import { automap } from \"../ast\";\r\nimport { ParseNode } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypeAnnotationNode } from \"./TypeAnnotationNode\";\r\n\r\nexport class DefinitionNode extends ParseNode<{\r\n  name: string;\r\n  type: TypeAnnotationNode;\r\n}> {\r\n  debug(): string {\r\n    return `(${this.d.type.debug()} ${this.d.name})`;\r\n  }\r\n  exec(ctx: ExecutionContext) {\r\n    throw new Error(\"Type definitions should not be exec()ed.\");\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.type, cb);\r\n  }\r\n\r\n  *checkInner(ctx) {\r\n    yield this.d.type.check(ctx);\r\n  }\r\n}\r\n", "import {\r\n  ParseStatement,\r\n  autodebug,\r\n  automap,\r\n  handleStatementList,\r\n} from \"../ast\";\r\nimport { ParseNode, TypeErrorFeedback } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypecheckContext } from \"../typecheck\";\r\n\r\nexport class ElseNode extends ParseNode<{\r\n  body: ParseStatement[];\r\n}> {\r\n  debug(): string {\r\n    return `(${autodebug(this.d.body)})`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    ctx = ctx.clone();\r\n\r\n    ctx = handleStatementList(ctx, this.d.body).ctx;\r\n\r\n    return ctx;\r\n  }\r\n\r\n  mapInner(cb) {\r\n    automap(this.d.body, cb);\r\n  }\r\n\r\n  *checkInner(ctx: TypecheckContext) {\r\n    const checks: TypeErrorFeedback[] = [];\r\n    ctx.withBlock(() => {\r\n      for (const stmt of this.d.body) checks.push(...stmt.check(ctx));\r\n    });\r\n    yield checks;\r\n  }\r\n}\r\n", "import { ParseNode, TypeErrorFeedback } from \"../parser-utils\";\r\nimport { ExecutionContext } from \"../runtime/runtime\";\r\nimport { TypecheckContext } from \"../typecheck\";\r\n\r\nexport class TypeAnnotationNode extends ParseNode<{\r\n  struct: boolean;\r\n  name: string;\r\n  pointers: number;\r\n}> {\r\n  debug(): string {\r\n    return `${this.d.struct ? \"struct \" : \"\"}${this.d.name} ${\"\".padStart(\r\n      this.d.pointers,\r\n      \"*\"\r\n    )}`;\r\n  }\r\n\r\n  exec(ctx: ExecutionContext) {\r\n    throw new Error(\"Type annotations should not be exec()ed.\");\r\n    return ctx;\r\n  }\r\n\r\n  mapInner() {}\r\n\r\n  *checkInner(\r\n    ctx: TypecheckContext\r\n  ): IterableIterator<TypeErrorFeedback | TypeErrorFeedback[] | undefined> {}\r\n}\r\n", "import { Operator, UnaryOperator } from \"./lexing\";\r\nimport { AssignmentNode } from \"./nodes/AssignmentNode\";\r\nimport { BinaryOpNode } from \"./nodes/BinaryOpNode\";\r\nimport { ErrorNode } from \"./nodes/ErrorNode\";\r\nimport { FunctionCallNode } from \"./nodes/FunctionCallNode\";\r\nimport { FunctionDefNode } from \"./nodes/FunctionDefNode\";\r\nimport { IdentifierNode } from \"./nodes/IdentifierNode\";\r\nimport { IfNode } from \"./nodes/IfNode\";\r\nimport { LoopNode } from \"./nodes/LoopNode\";\r\nimport { NumberNode } from \"./nodes/NumberNode\";\r\nimport { ReturnStatementNode } from \"./nodes/ReturnStatementNode\";\r\nimport { StatementListNode } from \"./nodes/StatementListNode\";\r\nimport { StringLiteralNode } from \"./nodes/StringLiteralNode\";\r\nimport { StructDefinitionNode } from \"./nodes/StructDefinitionNode\";\r\nimport { TypecastNode } from \"./nodes/TypecastNode\";\r\nimport { UnaryOpNode } from \"./nodes/UnaryOpNode\";\r\nimport { VariableDefinitionNode } from \"./nodes/VariableDefinitionNode\";\r\nexport { AssignmentNode } from \"./nodes/AssignmentNode\";\r\nexport { BinaryOpNode } from \"./nodes/BinaryOpNode\";\r\nexport { ErrorNode } from \"./nodes/ErrorNode\";\r\nexport { FunctionCallNode } from \"./nodes/FunctionCallNode\";\r\nexport { FunctionDefNode } from \"./nodes/FunctionDefNode\";\r\nexport { IdentifierNode } from \"./nodes/IdentifierNode\";\r\nexport { IfNode } from \"./nodes/IfNode\";\r\nexport { LoopNode } from \"./nodes/LoopNode\";\r\nexport { NumberNode } from \"./nodes/NumberNode\";\r\nexport { ReturnStatementNode } from \"./nodes/ReturnStatementNode\";\r\nexport { StatementListNode } from \"./nodes/StatementListNode\";\r\nexport { StringLiteralNode } from \"./nodes/StringLiteralNode\";\r\nexport { StructDefinitionNode } from \"./nodes/StructDefinitionNode\";\r\nexport { TypecastNode } from \"./nodes/TypecastNode\";\r\nexport { UnaryOpNode } from \"./nodes/UnaryOpNode\";\r\nexport { VariableDefinitionNode } from \"./nodes/VariableDefinitionNode\";\r\nexport { DefinitionNode } from \"./nodes/DefinitionNode\";\r\nexport { ElseNode } from \"./nodes/ElseNode\";\r\nexport { TypeAnnotationNode } from \"./nodes/TypeAnnotationNode\";\r\nimport { ParseNode, TypeErrorFeedback } from \"./parser-utils\";\r\nimport {\r\n  AnonymousVariableInstance,\r\n  DefaultPrimitives,\r\n  DefaultTypes,\r\n  ExecutionContext,\r\n  FloatsBySize,\r\n  IntsBySize,\r\n  StackFrame,\r\n  UintsBySize,\r\n  assertPrimitiveTypeDef,\r\n  constructTypeFromNode,\r\n  execAndRetrieveData,\r\n} from \"./runtime/runtime\";\r\nimport {\r\n  CTypeError,\r\n  IParseExpr,\r\n  MaybeType,\r\n  TypecheckContext,\r\n  combineTypesForArithmetic,\r\n  combineTypesForBitwise,\r\n  combineTypesForComparisonAndLogical,\r\n  isStruct,\r\n  organizeTypeErrors,\r\n  typeErr,\r\n  typeSuccess,\r\n  typeToString,\r\n  typecheckBinaryOperation,\r\n  typecheckUnaryOperation,\r\n} from \"./typecheck\";\r\n\r\nexport type ParseExpr =\r\n  | ErrorNode\r\n  | NumberNode\r\n  | IdentifierNode\r\n  | FunctionCallNode\r\n  | BinaryOpNode\r\n  | UnaryOpNode\r\n  | StringLiteralNode\r\n  | TypecastNode;\r\n\r\n// TODO: deal with expression statements leaving extra garbage on the stack\r\n//       do not misalign the stack!!!!\r\nexport type ParseStatement =\r\n  | ParseExpr\r\n  | AssignmentNode\r\n  | FunctionDefNode\r\n  | VariableDefinitionNode\r\n  | IfNode\r\n  | StructDefinitionNode\r\n  | LoopNode\r\n  | ReturnStatementNode;\r\n\r\nexport function autodebug(node?: ParseNode<any> | ParseNode<any>[]) {\r\n  if (Array.isArray(node)) {\r\n    return node.map((n) => n.debug()).join(\" \");\r\n  } else if (node) {\r\n    return node.debug();\r\n  }\r\n  return \"\";\r\n}\r\n\r\nexport function handleStatementList(\r\n  ctx: ExecutionContext,\r\n  body: ParseStatement[]\r\n) {\r\n  const top = ctx.stacktop();\r\n  ctx.pushBlock();\r\n  for (const stmt of body) {\r\n    ctx = stmt.exec(ctx);\r\n\r\n    // if we freed the current stack frame, exit early\r\n    if (top.freed) {\r\n      return {\r\n        returned: true,\r\n        ctx,\r\n      };\r\n    }\r\n  }\r\n  ctx.popBlock();\r\n  return {\r\n    returned: false,\r\n    ctx,\r\n  };\r\n}\r\n\r\nexport function* defaultExprCheck(\r\n  expr: IParseExpr & ParseNode<any>,\r\n  ctx: TypecheckContext\r\n) {\r\n  const type = expr.type(ctx);\r\n  if (type.success) return [];\r\n  return { ...type.why };\r\n}\r\n\r\nexport class ExecutionError extends Error {\r\n  ctx: ExecutionContext;\r\n\r\n  constructor(msg: string, ctx: ExecutionContext) {\r\n    super(msg);\r\n    this.ctx = ctx;\r\n  }\r\n}\r\n\r\nexport function automap(\r\n  node: ParseNode<any> | ParseNode<any>[] | undefined,\r\n  callback: (n: ParseNode<any>) => void\r\n) {\r\n  if (Array.isArray(node)) {\r\n    node.map((n) => n.map(callback));\r\n  } else if (node instanceof ParseNode) {\r\n    node.map(callback);\r\n  }\r\n}\r\n", "import { StringLiteralNode } from \"./ast\";\r\nimport { ParseNode } from \"./parser-utils\";\r\n\r\ntype AllocateStringLiteralsCtx = {\r\n  mem: ArrayBuffer;\r\n};\r\n\r\nexport function concatArrayBuffers(a: ArrayBuffer, b: ArrayBuffer) {\r\n  const concatted = new ArrayBuffer(a.byteLength + b.byteLength);\r\n  const byteArray = new Uint8Array(concatted);\r\n  const byteArrayA = new Uint8Array(a);\r\n  const byteArrayB = new Uint8Array(b);\r\n  for (let i = 0; i < byteArrayA.length; i++) {\r\n    byteArray[i] = byteArrayA[i];\r\n  }\r\n  for (let i = 0; i < byteArrayB.length; i++) {\r\n    byteArray[i + byteArrayA.length] = byteArrayB[i];\r\n  }\r\n  return concatted;\r\n}\r\n\r\nexport function allocateStringLiterals(\r\n  ast: ParseNode<any>,\r\n  ctx: AllocateStringLiteralsCtx\r\n) {\r\n  function recurse(n: ParseNode<any>) {\r\n    if (n instanceof StringLiteralNode) {\r\n      const strbuf = new TextEncoder().encode(n.d.str + \"\\0\");\r\n\r\n      n.d.pointer = ctx.mem.byteLength;\r\n\r\n      ctx.mem = concatArrayBuffers(ctx.mem, strbuf);\r\n    }\r\n  }\r\n\r\n  ast.map(recurse);\r\n}\r\n", "import {\r\n  ErrorNode,\r\n  TypeAnnotationNode,\r\n  DefinitionNode,\r\n  StatementListNode,\r\n  ParseStatement,\r\n  IfNode,\r\n  ElseNode,\r\n  AssignmentNode,\r\n  FunctionDefNode,\r\n  VariableDefinitionNode,\r\n  ParseExpr,\r\n  NumberNode,\r\n  FunctionCallNode,\r\n  IdentifierNode,\r\n  BinaryOpNode,\r\n  LoopNode,\r\n  StructDefinitionNode,\r\n  ReturnStatementNode,\r\n  UnaryOpNode,\r\n  StringLiteralNode,\r\n  TypecastNode,\r\n} from \"./ast\";\r\nimport {\r\n  Operator,\r\n  UnaryOperator,\r\n  charLiteralRegex,\r\n  identRegex,\r\n  numberRegex,\r\n  numberTypeRegex,\r\n  opRegex,\r\n  stringLiteralRegex,\r\n  unaryOpRegex,\r\n} from \"./lexing\";\r\nimport {\r\n  BindingPowers,\r\n  Highlight,\r\n  Matcher,\r\n  MutableParseSourceWrapper,\r\n  ParseSource,\r\n  UnaryBindingPowers,\r\n  requiresSemicolon,\r\n} from \"./parser-utils\";\r\n\r\nfunction getBindingPowerOfNextToken(s: ParseSource): number {\r\n  const str = s.isNext(opRegex);\r\n\r\n  if (!str) return 0;\r\n\r\n  return BindingPowers[str as Operator] ?? 0;\r\n}\r\n\r\nfunction enclose<T>(\r\n  start: ParseSource,\r\n  muts: MutableParseSourceWrapper,\r\n  end: Matcher,\r\n  endErr: string,\r\n  highlightEnds: Highlight,\r\n  callback: (muts: MutableParseSourceWrapper) => T\r\n): Exclude<T, ErrorNode>[] | ErrorNode {\r\n  const items: T[] = [];\r\n\r\n  while (!muts.isNext(end)) {\r\n    const item = callback(muts);\r\n    if (item instanceof ErrorNode) return item;\r\n    items.push(item);\r\n  }\r\n\r\n  if (!muts.expect(end, highlightEnds)) return muts.err(start, endErr);\r\n\r\n  return items as Exclude<T, ErrorNode>[];\r\n}\r\n\r\nexport function parseTypeAnnotation(s: ParseSource) {\r\n  const muts = s.mut();\r\n\r\n  const struct = !!muts.expect(\"struct\", \"keyword\");\r\n\r\n  // edge case: unsigned keyword (no time to make more complex compound types with stuff like const unfortunately)\r\n  const unsigned = struct ? undefined : muts.expect(\"unsigned\", \"type\");\r\n\r\n  let name = muts.expect(identRegex, \"type\");\r\n  if (!name) return muts.err(s, \"Expected a type name.\");\r\n\r\n  if (unsigned) name = `unsigned ${name}`;\r\n\r\n  let pointers = 0;\r\n\r\n  while (muts.isNext(\"*\")) {\r\n    muts.expect(\"*\", \"operator\");\r\n    pointers++;\r\n  }\r\n\r\n  return new TypeAnnotationNode(s, muts.current(), {\r\n    struct,\r\n    name,\r\n    pointers,\r\n  });\r\n}\r\n\r\nexport function parseDefinition(s: ParseSource) {\r\n  const muts = s.mut();\r\n\r\n  const type = muts.parse(parseTypeAnnotation, 0);\r\n\r\n  if (type instanceof ErrorNode) return type;\r\n\r\n  const name = muts.expect(identRegex, \"type\");\r\n\r\n  if (!name) return muts.err(s, \"Expected an identifier.\");\r\n\r\n  return new DefinitionNode(s, muts.current(), {\r\n    type,\r\n    name,\r\n  });\r\n}\r\n\r\nexport function parseStatementList(\r\n  s: ParseSource\r\n): StatementListNode | ErrorNode {\r\n  const muts = s.mut();\r\n  const body: ParseStatement[] = [];\r\n  while (true) {\r\n    const stmt = muts.parse(parseStatement, 0);\r\n    if (stmt instanceof ErrorNode) break;\r\n    body.push(stmt);\r\n\r\n    if (requiresSemicolon(stmt) && !muts.expect(\";\", \"semicolon\"))\r\n      return muts.err(s, \"Expected ';'\");\r\n  }\r\n  return new StatementListNode(s, muts.current(), {\r\n    body,\r\n  });\r\n}\r\n\r\nfunction getCondition(start: ParseSource, muts: MutableParseSourceWrapper) {\r\n  if (!muts.expect(\"(\", \"bracket\")) return muts.err(start, \"Expected '('\");\r\n\r\n  const condition = muts.parse(parseExpr, 0);\r\n\r\n  if (!muts.expect(\")\", \"bracket\")) return muts.err(start, \"Expected ')'\");\r\n\r\n  return condition;\r\n}\r\n\r\nfunction parseLoop(s: ParseSource) {\r\n  const muts = s.mut();\r\n  return muts.match(\r\n    [\r\n      [\r\n        \"for\",\r\n        \"keyword\",\r\n        () => {\r\n          if (!muts.expect(\"(\", \"bracket\")) return muts.err(s, \"Expected '('\");\r\n\r\n          let start, iter: ParseStatement | undefined;\r\n          let condition: ParseExpr | undefined;\r\n\r\n          if (!muts.isNext(\";\")) {\r\n            start = muts.parse(parseStatement, 0);\r\n          }\r\n          if (!muts.expect(\";\", \"semicolon\"))\r\n            return muts.err(s, \"Expected ';'\");\r\n          if (!muts.isNext(\";\")) {\r\n            condition = muts.parse(parseExpr, 0);\r\n          }\r\n          if (!muts.expect(\";\", \"semicolon\"))\r\n            return muts.err(s, \"Expected ';'\");\r\n          if (!muts.isNext(\")\")) {\r\n            iter = muts.parse(parseStatement, 0);\r\n          }\r\n          if (!muts.expect(\")\", \"bracket\")) return muts.err(s, \"Expected ')'\");\r\n\r\n          const body = parseCurlyBracesDelimitedBody(s, muts);\r\n\r\n          if (body instanceof ErrorNode) return body;\r\n\r\n          return new LoopNode(s, muts.current(), {\r\n            body,\r\n            conditions: {\r\n              type: \"for\",\r\n              start,\r\n              condition,\r\n              iter,\r\n            },\r\n          });\r\n        },\r\n      ],\r\n      [\r\n        \"while\",\r\n        \"keyword\",\r\n        () => {\r\n          const condition = getCondition(s, muts);\r\n\r\n          if (condition instanceof ErrorNode) return condition;\r\n\r\n          const body = parseCurlyBracesDelimitedBody(s, muts);\r\n\r\n          if (body instanceof ErrorNode) return body;\r\n\r\n          return new LoopNode(s, muts.current(), {\r\n            conditions: {\r\n              type: \"while\",\r\n              condition,\r\n            },\r\n            body,\r\n          });\r\n        },\r\n      ],\r\n    ],\r\n    () => muts.err(s, \"Expected 'for' or 'while'.\")\r\n  );\r\n}\r\n\r\nfunction parseIfElseStatement(s: ParseSource) {\r\n  let muts = s.mut();\r\n  return muts.match(\r\n    [\r\n      [\r\n        \"if\",\r\n        \"keyword\",\r\n        () => {\r\n          const condition = getCondition(s, muts);\r\n\r\n          if (condition instanceof ErrorNode) return condition;\r\n\r\n          const body = parseCurlyBracesDelimitedBody(s, muts);\r\n\r\n          if (body instanceof ErrorNode) return body;\r\n\r\n          let elseif: IfNode | ElseNode | undefined;\r\n\r\n          if (muts.isNext(\"else\")) {\r\n            elseif = muts.parse(parseIfElseStatement, 0);\r\n          }\r\n\r\n          return new IfNode(s, muts.current(), {\r\n            condition,\r\n            body,\r\n            elseif,\r\n          });\r\n        },\r\n      ],\r\n      [\r\n        \"else\",\r\n        \"keyword\",\r\n        () => {\r\n          if (muts.isNext(\"if\")) return muts.parse(parseIfElseStatement, 0);\r\n\r\n          const body = parseCurlyBracesDelimitedBody(s, muts);\r\n\r\n          if (body instanceof ErrorNode) return body;\r\n\r\n          return new ElseNode(s, muts.current(), {\r\n            body,\r\n          });\r\n        },\r\n      ],\r\n    ],\r\n    () => muts.err(s, \"Expected 'if'.\")\r\n  );\r\n}\r\n\r\nfunction parseCurlyBracesDelimitedBody(\r\n  start: ParseSource,\r\n  muts: MutableParseSourceWrapper\r\n) {\r\n  if (!muts.expect(\"{\", \"bracket\")) return muts.err(start, \"Expected '{'\");\r\n\r\n  return enclose(start, muts, \"}\", \"Expected '}'\", \"bracket\", (muts) => {\r\n    const stmt = muts.parse(parseStatement, 0);\r\n    if (stmt instanceof ErrorNode) return stmt;\r\n\r\n    if (requiresSemicolon(stmt) && !muts.expect(\";\", \"semicolon\"))\r\n      return muts.err(start, \"Expected ';'\");\r\n\r\n    return stmt;\r\n  });\r\n}\r\n\r\nexport function parseStatement(s: ParseSource): ParseStatement {\r\n  let muts = s.mut();\r\n\r\n  if (muts.expect(\"return\", \"keyword\")) {\r\n    let expr: ParseExpr | undefined = muts.parse(parseExpr, 0);\r\n\r\n    if (expr instanceof ErrorNode && muts.isNext(\";\")) expr = undefined;\r\n\r\n    if (expr instanceof ErrorNode) return expr;\r\n\r\n    return new ReturnStatementNode(s, muts.current(), {\r\n      expr,\r\n    });\r\n  }\r\n\r\n  // struct definition\r\n  if (muts.expect(\"struct\", \"keyword\")) {\r\n    const name = muts.expect(identRegex, \"identifier\");\r\n\r\n    if (!name) return muts.err(s, \"Expected an identifier.\");\r\n\r\n    if (!muts.expect(\"{\", \"bracket\")) return muts.err(s, \"Expected '{'\");\r\n\r\n    const fields = enclose(s, muts, \"}\", \"Expected '}'\", \"bracket\", (muts) => {\r\n      const def = muts.parse(parseDefinition, 0);\r\n      if (!muts.expect(\";\", \"semicolon\")) return muts.err(s, \"Expected ';'\");\r\n      return def;\r\n    });\r\n\r\n    if (fields instanceof ErrorNode) return fields;\r\n\r\n    return new StructDefinitionNode(s, muts.current(), {\r\n      fields,\r\n      name,\r\n    });\r\n  }\r\n\r\n  muts = s.mut();\r\n\r\n  const def = muts.parse(parseDefinition, 0);\r\n\r\n  // doesnt start with type declaration -> probably an assignment\r\n  if (def instanceof ErrorNode) {\r\n    muts = s.mut();\r\n\r\n    // TODO: properly handle variables/stuff that start with \"if\" and other similar cases.\r\n    // if/else chain\r\n    if (muts.isNext(\"if\")) {\r\n      const ifStmt = muts.parse(parseIfElseStatement, 0);\r\n\r\n      return ifStmt;\r\n    }\r\n\r\n    // for/while loop\r\n    if (muts.isNext(\"for\") || muts.isNext(\"while\")) {\r\n      const loop = muts.parse(parseLoop, 0);\r\n\r\n      return loop;\r\n    }\r\n\r\n    // variable assignment\r\n    const assignment = (() => {\r\n      muts = s.mut();\r\n\r\n      const left = muts.parse(parseExpr, 200);\r\n\r\n      if (left instanceof ErrorNode) return;\r\n\r\n      const op = muts.expect(opRegex, \"operator\") as Operator | undefined;\r\n\r\n      if (!muts.expect(\"=\", \"operator\")) return;\r\n\r\n      const right = muts.parse(parseExpr, 0);\r\n\r\n      if (right instanceof ErrorNode) return;\r\n\r\n      return new AssignmentNode(s, muts.current(), {\r\n        left,\r\n        op,\r\n        right,\r\n      });\r\n    })();\r\n\r\n    if (!assignment) return parseExpr(s);\r\n\r\n    return assignment;\r\n  }\r\n\r\n  // variable or function or struct definition\r\n  return muts.match<ParseStatement>(\r\n    [\r\n      [\r\n        \"(\",\r\n        \"bracket\",\r\n        () => {\r\n          const args = enclose(\r\n            s,\r\n            muts,\r\n            \")\",\r\n            \"Expected ')'\",\r\n            \"bracket\",\r\n            (muts) => {\r\n              const def = muts.parse(parseDefinition, 0);\r\n              if (!muts.expect(\",\", \"operator\") && !muts.isNext(\")\"))\r\n                return muts.err(s, \"Expected ','\");\r\n              return def;\r\n            }\r\n          );\r\n\r\n          if (args instanceof ErrorNode) return args;\r\n\r\n          const body = parseCurlyBracesDelimitedBody(s, muts);\r\n\r\n          if (body instanceof ErrorNode) return body;\r\n\r\n          return new FunctionDefNode(s, muts.current(), {\r\n            returnTypeAndName: def,\r\n            args,\r\n            body,\r\n          });\r\n        },\r\n      ],\r\n      [\r\n        \"=\",\r\n        \"operator\",\r\n        (name) => {\r\n          const value = muts.parse(parseExpr, 0);\r\n\r\n          if (value instanceof ErrorNode) return value;\r\n\r\n          return new VariableDefinitionNode(s, muts.current(), {\r\n            value,\r\n            definition: def,\r\n          });\r\n        },\r\n      ],\r\n      [\r\n        \";\",\r\n        \"semicolon\",\r\n        () => {\r\n          return new VariableDefinitionNode(s, muts.current(), {\r\n            definition: def,\r\n          });\r\n        },\r\n      ],\r\n    ],\r\n    () => {\r\n      return parseExpr(s);\r\n    }\r\n  );\r\n\r\n  return parseExpr(s);\r\n}\r\n\r\nexport function parseExpr(s: ParseSource): ParseExpr {\r\n  // parse initial expr, returning it if it's an error\r\n  let left = parseInitExpr(s);\r\n  if (left instanceof ErrorNode) return left;\r\n  let currentSrc = left.end;\r\n\r\n  while (true) {\r\n    // set binding power and leave early if applicable\r\n    const nextBindingPower = getBindingPowerOfNextToken(currentSrc);\r\n    if (nextBindingPower <= s.bindingPower()) break;\r\n\r\n    // try to parse the consequent expr, leaving early on error\r\n    const consequent = parseConsequentExpr(\r\n      left.setBindingPower(nextBindingPower)\r\n    );\r\n    if (consequent instanceof ErrorNode) break;\r\n\r\n    left = consequent;\r\n  }\r\n\r\n  return left;\r\n}\r\n\r\nfunction decodeString(str: string) {\r\n  let decodedStr = \"\";\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (str[i] === \"\\\\\") {\r\n      switch (str[++i]) {\r\n        case \"t\":\r\n        case \"r\":\r\n        case \"n\":\r\n        case \"0\":\r\n        case \"\\\\\":\r\n          decodedStr += {\r\n            t: \"\\t\",\r\n            r: \"\\r\",\r\n            n: \"\\n\",\r\n            \"0\": \"\\0\",\r\n            \"\\\\\": \"\\\\\",\r\n          }[str[i]];\r\n          break;\r\n        case \"x\": {\r\n          const num = parseInt(str[++i] + str[++i], 16);\r\n          decodedStr += String.fromCharCode(num);\r\n          break;\r\n        }\r\n        case \"u\": {\r\n          const num = parseInt(str[++i] + str[++i] + str[++i] + str[++i], 16);\r\n          decodedStr += String.fromCharCode(num);\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      decodedStr += str[i];\r\n    }\r\n  }\r\n\r\n  return decodedStr;\r\n}\r\n\r\nfunction parseInitExpr(s: ParseSource): ParseExpr {\r\n  let muts = s.mut();\r\n  return muts.match<ParseExpr>(\r\n    [\r\n      // char literal\r\n      [\r\n        charLiteralRegex,\r\n        \"string\",\r\n        (str) => {\r\n          const char = decodeString(str.slice(1, -1));\r\n\r\n          return new NumberNode(s, muts.current(), {\r\n            num: Number(char.charCodeAt(0)),\r\n            type: \"i\",\r\n            bytes: 1,\r\n          });\r\n        },\r\n      ],\r\n\r\n      // string literal\r\n      [\r\n        stringLiteralRegex,\r\n        \"string\",\r\n        (inputStr) => {\r\n          const str = decodeString(inputStr.slice(1, -1));\r\n\r\n          return new StringLiteralNode(s, muts.current(), {\r\n            str,\r\n            pointer: 0,\r\n          });\r\n        },\r\n      ],\r\n\r\n      // unary op\r\n      [\r\n        unaryOpRegex,\r\n        \"operator\",\r\n        (op) => {\r\n          const value = muts.parse(parseExpr, UnaryBindingPowers[op]);\r\n\r\n          return new UnaryOpNode(s, muts.current(), {\r\n            value,\r\n            op: op as UnaryOperator,\r\n          });\r\n        },\r\n      ],\r\n      // parenthesized\r\n      [\r\n        \"(\",\r\n        \"bracket\",\r\n        () => {\r\n          let beforeTypecast = muts.current();\r\n\r\n          const typecast = muts.parse(parseTypeAnnotation, 0);\r\n\r\n          if (typecast instanceof TypeAnnotationNode) {\r\n            const typecastNode = (() => {\r\n              if (!muts.expect(\")\", \"bracket\")) return;\r\n\r\n              const value = muts.parse(parseExpr, 150);\r\n              if (value instanceof ErrorNode) return;\r\n\r\n              return new TypecastNode(s, muts.current(), {\r\n                type: typecast,\r\n                value,\r\n              });\r\n            })();\r\n\r\n            console.log(\"TYPECAST\", typecastNode);\r\n\r\n            if (typecastNode) return typecastNode;\r\n          }\r\n\r\n          muts = beforeTypecast.mut();\r\n\r\n          const expr = muts.parse(parseExpr, 0);\r\n\r\n          if (!muts.expect(\")\", \"bracket\")) return muts.err(s, \"Expected ')'.\");\r\n\r\n          return expr.setParserPointer(muts.current());\r\n        },\r\n      ],\r\n      // number\r\n      [\r\n        numberRegex,\r\n        \"number\",\r\n        (num) => {\r\n          const numtype =\r\n            (muts.expect(numberTypeRegex, \"number\") as\r\n              | \"f\"\r\n              | \"u\"\r\n              | \"i\"\r\n              | undefined) ?? (num.includes(\".\") ? \"f\" : \"i\");\r\n          return new NumberNode(s, muts.current(), {\r\n            num: Number(num),\r\n            type: numtype,\r\n          });\r\n        },\r\n      ],\r\n\r\n      [\r\n        identRegex,\r\n        \"identifier\",\r\n        (ident) => {\r\n          return muts.match<ParseExpr>(\r\n            [\r\n              // function call\r\n              [\r\n                \"(\",\r\n                \"bracket\",\r\n                () => {\r\n                  let args: ParseExpr[] = [];\r\n\r\n                  // argument list\r\n                  while (!muts.isNext(\")\")) {\r\n                    const arg = muts.parse<ParseExpr>(parseExpr, 0);\r\n                    if (arg instanceof ErrorNode) return arg;\r\n                    args.push(arg);\r\n                    if (!muts.expect(\",\", \"comma\")) break;\r\n                  }\r\n\r\n                  // closing brace\r\n                  if (!muts.expect(\")\", \"bracket\"))\r\n                    return muts.err(s, \"Expected a ')'.\");\r\n\r\n                  return new FunctionCallNode(s, muts.current(), {\r\n                    args,\r\n                    name: ident,\r\n                  });\r\n                },\r\n              ],\r\n            ],\r\n\r\n            // identifier\r\n            () => new IdentifierNode(s, muts.current(), { name: ident })\r\n          );\r\n        },\r\n      ],\r\n    ],\r\n    () => muts.err(s, \"Expected a number or an identifier.\")\r\n  );\r\n}\r\n\r\nfunction parseConsequentExpr(left: ParseExpr) {\r\n  console.log(\"LEFT\", left);\r\n  const muts = left.end.mut();\r\n  return muts.match<ParseExpr>(\r\n    [\r\n      // binary op\r\n      [\r\n        opRegex,\r\n        \"operator\",\r\n        (op) => {\r\n          const bp = getBindingPowerOfNextToken(left.end);\r\n\r\n          const right = muts.parse(parseExpr, bp);\r\n\r\n          return new BinaryOpNode(left.start, muts.current(), {\r\n            left,\r\n            right,\r\n            op: op as Operator,\r\n          });\r\n        },\r\n      ],\r\n    ],\r\n    () => muts.err(left.start, \"Expected a binary operator.\")\r\n  );\r\n}\r\n", "import { allocateStringLiterals, concatArrayBuffers } from \"./allocate\";\r\nimport { parseStatementList } from \"./parser\";\r\nimport { ParseInput } from \"./parser-utils\";\r\nimport {\r\n  DefaultPrimitives,\r\n  DefaultTypes,\r\n  ExecutionContext,\r\n} from \"./runtime/runtime\";\r\n\r\n/*\r\nThe crux of the typechecking problem:\r\n- I don't want to implement a secondary typechecking system.\r\n- But I also can't really integrate it within the current system because \r\n  doing that wouldn't be exhaustive and would mimic the way a dynamic language\r\n  handles type/error checking more than a static language. I don't want the\r\n  errors to depend on which branch of an if-else chain I end up entering.\r\n- I might want to implement a \"type\" function for each thing which statically\r\n  checks its type. I think that to some degree this problem is unsolvable. This\r\n  is because there's no equivalent for assembly-based languages: All I can do is\r\n  ensure that my types are correct. The assembly can still be broken.\r\n\r\nHigh priority:\r\nTODO: Implement arrays\r\nTODO: Prevent parsing bug with variables starting with \"if\", \"while\", etc.\r\n\r\nMed priority:\r\nTODO: Implement print with format codes (actual printf)\r\nTODO: Implement a typechecking layer and define proper behavior for bitwise ops and whatnot\r\n\r\nLow priority:\r\nTODO: Test structs and fix the ridiculous amount of inevitable bugs\r\nTODO: struct members\r\n*/\r\n\r\nconst TEST1 = `\r\n\r\nwhile (x > 3) {\r\n    x += 1;\r\n}\r\n\r\nfor (int i = 0; i < 100; i += 1) {\r\n    b += i;\r\n    c += 2 * i;\r\n}\r\n\r\nstruct person {\r\n    char* name;\r\n    int age;\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n    int x = 0;\r\n    x = 3;\r\n    x += 1;\r\n\r\n    if (x > 3) {\r\n        x *= 1;\r\n    } else if (x < 0) {\r\n        x += cos(69.123);\r\n    } else {\r\n        printf(fart.poopy);\r\n    }\r\n\r\n    printf(x);\r\n}\r\n\r\n`;\r\n\r\nconst TEST2 = `\r\n\r\nchar* strtest = \"fart\";\r\n\r\nint quadruple(int n) {\r\n    return n * 4;\r\n}\r\n\r\nint x = 5;\r\n\r\nx = x + 69;\r\n\r\nx *= 3;\r\n\r\nx = quadruple(x);\r\n\r\nif (x == 888) {\r\n    x += 1;\r\n}\r\n\r\nif (x < 0) {\r\n    x += 1;\r\n} else {\r\n    int y = 32;\r\n}\r\n\r\nint y = 32;\r\n\r\nwhile (x > 0) {\r\n    x -= 1;\r\n    y += 1;\r\n}\r\n\r\nx += 69;\r\n\r\nint* z = &x;\r\n\r\nint fart = *z; \r\n\r\nint incX() {\r\n    x += 1;\r\n}\r\n\r\nincX();\r\nincX();\r\nincX();\r\n\r\nfor (int i = 0; i < 10; i += 1) {\r\n    incX();\r\n}\r\n\r\nchar chartest1 = 'a';\r\nchar chartest2 = 'b';\r\n\r\nint printstr(char * str) {\r\n    while (*str != '\\\\0') {\r\n        putc(*str);\r\n\r\n        str += 1;\r\n    }\r\n}\r\n\r\nint printnum(int num) {\r\n    int placevalue = 1;\r\n    \r\n    while (placevalue <= num) {\r\n        placevalue *= 10;\r\n    }\r\n\r\n    placevalue /= 10;\r\n\r\n    while (placevalue > 0) {\r\n        putc(48 + ((num / placevalue) % 10));\r\n\r\n        placevalue /= 10;\r\n    }\r\n}\r\n\r\nchar * test1 = \"aaaabbbbccccdddd\\\\n\";\r\n\r\nprintstr(\"test\\\\n\");\r\nprintstr(\"another test\\\\n\");\r\nprintstr(\"yet another test\\\\n\");\r\nprintstr(\"test custom print fn \");\r\nprintnum(42069);\r\nprintstr(\"\\\\n\");\r\nprintnum(1000);\r\nprintstr(\"\\\\n\");\r\nprintnum(999);\r\nprintstr(\"\\\\n\");\r\nprintnum(1001);\r\nprintstr(\"\\\\n\");\r\n\r\nprintstr(test1);\r\nprintstr(test1 + 1);\r\nprintstr((int *)test1 + 1);`;\r\n\r\nfunction retrieveNullTerminatedString(mem: ArrayBuffer, i: number) {\r\n  const uint8array = new Uint8Array(mem);\r\n\r\n  const dst: number[] = [];\r\n\r\n  while (uint8array[i] != 0) {\r\n    dst.push(uint8array[i++]);\r\n  }\r\n\r\n  return new Uint8Array(dst).buffer;\r\n}\r\n\r\nconst parseInput = new ParseInput(TEST2, 0, 0);\r\n\r\nconst tree = parseStatementList(parseInput);\r\n\r\nconsole.log(tree);\r\nconsole.log(tree.debug());\r\n\r\nconst globalMem = {\r\n  mem: new ArrayBuffer(0),\r\n};\r\n\r\nallocateStringLiterals(tree, globalMem);\r\n\r\nlet stdout = \"\";\r\n\r\nconst finalState = tree.exec(\r\n  new ExecutionContext({\r\n    littleEndian: true,\r\n    memory: concatArrayBuffers(globalMem.mem, new ArrayBuffer(256)),\r\n    stack: [\r\n      {\r\n        blocks: [\r\n          {\r\n            bindings: new Map(),\r\n          },\r\n        ],\r\n        base: globalMem.mem.byteLength,\r\n        bindings: new Map(),\r\n        temporaries: [],\r\n        functionDefinitions: new Map([\r\n          [\r\n            \"printf\",\r\n            {\r\n              type: \"external\",\r\n              def(ctx, args) {\r\n                ctx = ctx.clone();\r\n                ctx = args[0].exec(ctx);\r\n                const value = ctx.popTempValueAndGetData();\r\n\r\n                const text = new TextDecoder().decode(\r\n                  retrieveNullTerminatedString(ctx.memory, value as number)\r\n                );\r\n\r\n                stdout += text;\r\n\r\n                return ctx;\r\n              },\r\n            },\r\n          ],\r\n          [\r\n            \"putc\",\r\n            {\r\n              type: \"external\",\r\n              def(ctx, args) {\r\n                ctx = ctx.clone();\r\n                ctx = args[0].exec(ctx);\r\n                const value = ctx.popTempValueAndGetData();\r\n                console.log(value);\r\n                stdout += String.fromCharCode(Number(value));\r\n                return ctx;\r\n              },\r\n            },\r\n          ],\r\n        ]),\r\n        freed: false,\r\n        returnType: {\r\n          definition: DefaultPrimitives.int,\r\n          pointers: 0,\r\n        },\r\n        argc: 0,\r\n      },\r\n    ],\r\n    esp: globalMem.mem.byteLength,\r\n    types: DefaultTypes,\r\n  })\r\n);\r\n\r\nconsole.log(finalState, new Uint8Array(finalState.memory));\r\n\r\nconsole.log(\"STDOUT\\n\", stdout);\r\n"],
  "mappings": "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",
  "names": ["hexDigit", "stringLiteralWithEscapeCodesAnd", "strs", "join", "charLiteralRegex", "RegExp", "stringLiteralRegex", "numberRegex", "identRegex", "skipRegex", "opRegex", "numberTypeRegex", "unaryOpRegex", "assert", "cond", "msg", "Error", "notNull", "v", "name", "ctx", "undefined", "console", "log", "ExecutionError", "bigintify", "n", "type", "definition", "category", "size", "BigInt", "ExecutionContext", "constructor", "opts", "prev", "stack", "memory", "littleEndian", "view", "DataView", "types", "esp", "getvar", "name", "stacktop", "bindings", "get", "clone", "sizeof", "pointers", "fields", "reduce", "field", "_setStruct", "instance", "value", "mem", "Uint8Array", "slice", "offset", "valAsUint8array", "i", "_getStruct", "setVar", "typecode", "useBigInt", "setterFn", "setUint32", "int1", "setInt8", "int2", "setInt16", "int4", "setInt32", "int8", "setBigInt64", "uint1", "setUint8", "uint2", "setUint16", "uint4", "uint8", "setBigUint64", "float4", "setFloat32", "float8", "setFloat64", "assert", "apply", "Number", "getVar", "getterFn", "getUint32", "getInt8", "getInt16", "getInt32", "getBigInt64", "getUint8", "getUint16", "getBigUint64", "getFloat32", "getFloat64", "_push", "doNotSetVar", "fieldname", "fieldvalue", "varInstance", "length", "blocktop", "blocks", "pushAnonymous", "temporaries", "push", "pushNamed", "binding", "set", "pushBlock", "Map", "popBlock", "block", "notNull", "pop", "reverse", "delete", "popTempValue", "val", "popTempValueAndGetData", "popTempValueAndGetBoth", "typeinfo", "addFunctionDefinition", "node", "functionDefinitions", "def", "getFunctionDefinition", "frame", "popStackFrame", "top", "ExecutionError", "freed", "base", "argc", "DefaultPrimitives", "long", "int", "short", "char", "float", "double", "bool", "IntsBySize", "UintsBySize", "FloatsBySize", "DefaultTypes", "Object", "entries", "map", "k", "v", "execAndRetrieveData", "ctx", "expr", "exec", "data", "constructTypeFromNode", "d", "typeErr", "node", "msgs", "success", "why", "map", "msg", "typeSuccess", "type", "organizeTypeErrors", "typeerrors", "errs", "filter", "t", "successes", "length", "undefined", "err", "flat", "isStruct", "definition", "category", "pointers", "isPointer", "isFloat", "typeToString", "basename", "name", "padStart", "combineTypesForArithmetic", "a", "b", "op", "aPointer", "bPointer", "biggestSize", "Math", "max", "size", "switchToFloat", "switchToSigned", "FloatsBySize", "IntsBySize", "combineTypesForComparisonAndLogical", "node", "a", "b", "op", "isStruct", "typeErr", "typeSuccess", "definition", "DefaultPrimitives", "char", "pointers", "combineTypesForBitwise", "isFloat", "isPointer", "combineTypesForArithmetic", "typecheckBinaryOperation", "ctx", "left", "right", "mltype", "type", "mrtype", "errs", "ltype", "rtype", "organizeTypeErrors", "pointerTo", "dereference", "typecheckUnaryOperation", "value", "mtype", "lv", "typeLValue", "errs2", "lvalueType", "matchOnString", "matcher", "str", "startsWith", "undefined", "Array", "isArray", "matchStr", "RegExp", "match", "exec", "index", "ParseInput", "position", "pos", "slice", "src", "constructor", "bindingPower", "bp", "isNext", "skipmatch", "skipRegex", "strmatch", "length", "expect", "highlight", "len", "branches", "fallback", "b", "result", "err", "start", "msg", "ErrorNode", "setBindingPower", "mut", "MutableParseInput", "map", "current", "parse", "nodetype", "node", "end", "ParseNode", "d", "check", "ctx", "errors", "checkInner", "flat", "filter", "e", "callback", "mapInner", "execLValue", "ExecutionError", "setParserPointer", "pp", "typeLValue", "typeErr", "checkLValue", "success", "why", "requiresSemicolon", "stmt", "IfNode", "FunctionDefNode", "StructDefinitionNode", "LoopNode", "BindingPowers", "UnaryBindingPowers", "handleBinaryOperation", "ctx", "op", "right", "popTempValueAndGetBoth", "left", "lv", "value", "rv", "ArrayBuffer", "ExecutionError", "typeinfo", "type", "definition", "category", "Number", "BigInt", "output", "outputType", "pointers", "leftIsPtr", "ptrVal", "nonPtrVal", "ptrType", "nonPtrType", "sizeof", "pushAnonymous", "+", "a", "b", "-", "*", "/", "%", "==", "!=", ">=", ">", "<=", "<", "&", "^", "|", ">>", "<<", "undefined", "BinaryOpNode", "ParseNode", "debug", "d", "exec", "clone", "mapInner", "cb", "automap", "typecheckBinaryOperation", "checkInner", "defaultExprCheck", "AssignmentNode", "ParseNode", "debug", "d", "op", "left", "right", "exec", "ctx", "clone", "execLValue", "handleBinaryOperation", "popTempValueAndGetBoth", "setVar", "type", "typeinfo", "offset", "value", "mapInner", "cb", "automap", "checkInner", "mltype", "typeLValue", "mrtype", "errs", "ltype", "rtype", "organizeTypeErrors", "why", "ErrorNode", "ParseNode", "debug", "d", "msg", "exec", "ctx", "ExecutionError", "mapInner", "cb", "type", "success", "why", "node", "checkInner", "defaultExprCheck", "FunctionCallNode", "ParseNode", "debug", "d", "name", "args", "map", "arg", "join", "exec", "ctx", "clone", "fndef", "getFunctionDefinition", "console", "log", "ExecutionError", "type", "def", "call", "mapInner", "cb", "automap", "functionTypeSig", "getFunctionTypes", "success", "length", "why", "node", "msg", "maybeArgTypes", "errs", "argTypes", "organizeTypeErrors", "badargs", "i", "isStruct", "definition", "push", "typeToString", "returns", "checkInner", "defaultExprCheck", "FunctionDefNode", "ParseNode", "debug", "d", "args", "map", "arg", "join", "body", "v", "exec", "ctx", "addFunctionDefinition", "returnTypeAndName", "name", "call", "clone", "ret", "types", "get", "type", "ExecutionError", "frame", "base", "esp", "bindings", "Map", "temporaries", "functionDefinitions", "freed", "returnType", "definition", "pointers", "argc", "length", "blocks", "offset", "slice", "reverse", "fnargType", "sizeof", "set", "stack", "push", "handleStatementList", "popStackFrame", "mapInner", "cb", "automap", "checkInner", "checks", "withStackFrame", "stmt", "check", "IdentifierNode", "ParseNode", "debug", "d", "name", "exec", "ctx", "clone", "data", "getvar", "ExecutionError", "pushAnonymous", "type", "getVar", "execLValue", "definition", "pointers", "offset", "mapInner", "getVariableType", "checkInner", "defaultExprCheck", "IfNode", "ParseNode", "debug", "d", "condition", "autodebug", "body", "elseif", "exec", "ctx", "clone", "top", "popTempValueAndGetData", "handleStatementList", "mapInner", "cb", "automap", "checkInner", "check", "checks", "withBlock", "stmt", "push", "LoopNode", "ParseNode", "debug", "d", "conditions", "type", "autodebug", "start", "condition", "iter", "body", "exec", "ctx", "clone", "stacktop", "end", "popBlock", "pushBlock", "cond", "popTempValueAndGetBoth", "value", "list", "handleStatementList", "returned", "freed", "undefined", "mapInner", "cb", "automap", "checkInner", "NumberNode", "ParseNode", "debug", "d", "num", "toString", "determineNumericType", "bytes", "type", "definition", "FloatsBySize", "pointers", "UintsBySize", "IntsBySize", "exec", "ctx", "ctx2", "clone", "pushAnonymous", "mapInner", "success", "checkInner", "defaultExprCheck", "ReturnStatementNode", "ParseNode", "debug", "autodebug", "d", "expr", "exec", "ctx", "clone", "outputValue", "output", "popTempValueAndGetBoth", "value", "frame", "popStackFrame", "pushAnonymous", "returnType", "mapInner", "cb", "automap", "checkInner", "check", "StatementListNode", "ParseNode", "debug", "d", "body", "map", "s", "join", "exec", "ctx", "clone", "handleStatementList", "mapInner", "cb", "automap", "checkInner", "stmt", "check", "StringLiteralNode", "ParseNode", "debug", "JSON", "stringify", "d", "str", "exec", "ctx", "clone", "pushAnonymous", "_type", "pointer", "mapInner", "callback", "definition", "DefaultPrimitives", "char", "pointers", "type", "typeSuccess", "checkInner", "defaultExprCheck", "StructDefinitionNode", "ParseNode", "debug", "d", "name", "autodebug", "fields", "exec", "ctx", "clone", "types", "set", "category", "map", "f", "fieldtype", "get", "type", "ExecutionError", "definition", "pointers", "mapInner", "cb", "automap", "checkInner", "TypecastNode", "ParseNode", "debug", "d", "value", "type", "exec", "ctx", "data", "execAndRetrieveData", "constructTypeFromNode", "pushAnonymous", "mapInner", "cb", "automap", "getTypeFromName", "checkInner", "defaultExprCheck", "UnaryOpNode", "ParseNode", "debug", "d", "op", "value", "exec", "ctx", "clone", "execLValue", "popTempValueAndGetBoth", "output", "outputType", "DefaultPrimitives", "bool", "typeinfo", "type", "pointers", "getVar", "offset", "Number", "pushAnonymous", "mapInner", "cb", "automap", "typecheckUnaryOperation", "checkInner", "defaultExprCheck", "typeLValue", "typeErr", "VariableDefinitionNode", "ParseNode", "debug", "d", "definition", "autodebug", "value", "exec", "ctx", "clone", "typeOfThisVar", "types", "get", "type", "name", "ExecutionError", "thingToAssign", "popTempValueAndGetBoth", "pushNamed", "pointers", "mapInner", "cb", "automap", "checkInner", "check", "fail", "organizeTypeErrors", "getTypeFromName", "why", "defineVariable", "DefinitionNode", "ParseNode", "debug", "d", "type", "name", "exec", "ctx", "Error", "mapInner", "cb", "automap", "checkInner", "check", "ElseNode", "ParseNode", "debug", "autodebug", "d", "body", "exec", "ctx", "clone", "handleStatementList", "mapInner", "cb", "automap", "checkInner", "checks", "withBlock", "stmt", "push", "check", "TypeAnnotationNode", "ParseNode", "debug", "d", "struct", "name", "padStart", "pointers", "exec", "ctx", "Error", "mapInner", "checkInner", "autodebug", "node", "Array", "isArray", "map", "n", "debug", "join", "handleStatementList", "ctx", "body", "top", "stacktop", "pushBlock", "stmt", "exec", "freed", "returned", "popBlock", "defaultExprCheck", "expr", "type", "success", "why", "ExecutionError", "Error", "constructor", "msg", "automap", "callback", "ParseNode", "concatArrayBuffers", "a", "b", "concatted", "ArrayBuffer", "byteLength", "byteArray", "Uint8Array", "byteArrayA", "byteArrayB", "i", "length", "allocateStringLiterals", "ast", "ctx", "recurse", "n", "StringLiteralNode", "strbuf", "TextEncoder", "encode", "d", "str", "pointer", "mem", "map", "getBindingPowerOfNextToken", "s", "str", "isNext", "opRegex", "BindingPowers", "enclose", "start", "muts", "end", "endErr", "highlightEnds", "callback", "items", "item", "ErrorNode", "push", "expect", "err", "parseTypeAnnotation", "mut", "struct", "unsigned", "undefined", "name", "identRegex", "pointers", "TypeAnnotationNode", "current", "parseDefinition", "type", "parse", "DefinitionNode", "parseStatementList", "body", "stmt", "parseStatement", "requiresSemicolon", "StatementListNode", "getCondition", "condition", "parseExpr", "parseLoop", "match", "iter", "parseCurlyBracesDelimitedBody", "LoopNode", "conditions", "parseIfElseStatement", "elseif", "IfNode", "ElseNode", "expr", "ReturnStatementNode", "fields", "def", "StructDefinitionNode", "ifStmt", "loop", "assignment", "left", "op", "right", "AssignmentNode", "args", "FunctionDefNode", "returnTypeAndName", "value", "VariableDefinitionNode", "definition", "parseInitExpr", "currentSrc", "nextBindingPower", "bindingPower", "consequent", "parseConsequentExpr", "setBindingPower", "decodeString", "decodedStr", "i", "length", "t", "r", "n", "num", "parseInt", "String", "fromCharCode", "charLiteralRegex", "char", "slice", "NumberNode", "Number", "charCodeAt", "bytes", "stringLiteralRegex", "inputStr", "StringLiteralNode", "pointer", "unaryOpRegex", "UnaryBindingPowers", "UnaryOpNode", "beforeTypecast", "typecast", "typecastNode", "TypecastNode", "console", "log", "setParserPointer", "numberRegex", "numtype", "numberTypeRegex", "includes", "ident", "arg", "FunctionCallNode", "IdentifierNode", "bp", "BinaryOpNode", "TEST2", "retrieveNullTerminatedString", "mem", "i", "uint8array", "Uint8Array", "dst", "push", "buffer", "parseInput", "ParseInput", "tree", "parseStatementList", "console", "log", "debug", "globalMem", "ArrayBuffer", "allocateStringLiterals", "stdout", "finalState", "exec", "ExecutionContext", "littleEndian", "memory", "concatArrayBuffers", "stack", "blocks", "bindings", "Map", "base", "byteLength", "temporaries", "functionDefinitions", "type", "def", "ctx", "args", "clone", "value", "popTempValueAndGetData", "text", "TextDecoder", "decode", "String", "fromCharCode", "Number", "freed", "returnType", "definition", "DefaultPrimitives", "int", "pointers", "argc", "esp", "types", "DefaultTypes"]
}
